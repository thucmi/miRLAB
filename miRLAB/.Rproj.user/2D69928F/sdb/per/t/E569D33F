{
    "contents" : "#\n\n# #Thuc add to increase heap size\n# options( java.parameters=\"-Xmx2048M\" )\n# #library(\"rJava\")\n# #javapath=system.file(\"extdata\", \"MINE.jar\", package=\"miRLAB\")\n# .jinit(classpath=\"MINE.jar\")\n# \n# ###########################################\n# # MINE - runs MINE on a comma-separated\n# #  values (CSV) file. All parameters are as\n# #  in the Java version. The parameters\n# #  var1.id and var2.id are for use when\n# #  the analysis style specified requires\n# #  more information. For instance, since\n# #  style=\"master.variable\" requires an\n# #  additional variable id (the id of the\n# #  master variable, you will need to\n# #  specify var1.id in this case.\n# #\n# #  As in the Java version, if you do not\n# #  specify a value for style, and you\n# #  specify a value for var1.id and not\n# #  var2.id, then style=\"master.variable\"\n# #  will be assumed. If you do not specify a\n# #  value for style, and you specify values\n# #  for both var1.id and var2.id, then\n# #  style=\"one.pair\" will be assumed.\n# #\n# # EXAMPLES:\n# #  MINE(\"Spellman.csv\",\"all.pairs\",0)\n# #  MINE(\"Spellman.csv\",0)\n# #   will both run MINE on \"Spellman.csv\"\n# #   and have it analyze each variable only\n# #   against the 0-th variable.\n# #\n# #  MINE(\"Spellman.csv\",\"one.pair\",0,5)\n# #  MINE(\"Spellman.csv\",0,5)\n# #   will both run MINE on \"Spellman.csv\"\n# #   and have it analyze only the 0-th\n# #   variable against the 5-th variable.\n# ###########################################\n# \n# MINE <- function (\n#   input.filename,\n#   style=c(\"master.variable\", \"all.pairs\", \"adjacent.pairs\", \"pairs.between\", \"one.pair\"),\n#   var1.id=NA,\n#   var2.id=NA,\n#   required.common.vals.fraction=0,\n#   max.num.boxes.exponent=0.6,\n#   notify.wait=100,\n#   num.clumps.factor=15,\n#   debug.level=0,\n#   gc.wait=Inf,\n#   job.id\n# ) {\n#   \n#   printHeader()\n#   \n#   params <- getParams(input.filename, style, var1.id, var2.id, required.common.vals.fraction, max.num.boxes.exponent, notify.wait, num.clumps.factor, debug.level, gc.wait, job.id)\n#   \n#   # run the analysis\n#   cat(\"reading in dataset...\\n\")\n#   flush.console()\n#   \n#   dataset <- .jnew(\"data/Dataset\",\n#                    params$inputfile,\n#                    params$analysisParams$mineParams$debug)\n#   \n#   cat(\"done.\\n\")\n#   flush.console()\n#   \n#   doAnalysis(dataset, params)\n# }\n# \n# ###########################################\n# # rMINE - runs MINE on an R matrix.\n# #  all parameters are as in MINE, except\n# #  that the name of the results file will\n# #  begin with output.prefix rather than\n# #  the name of the input file (since there\n# #  is no input file).\n# #\n# #  MINE assumes that each row of the\n# #  supplied matrix is a variable, and each\n# #  column is a record.\n# #\n# # EXAMPLE:\n# #  rMINE(matrix(1:10,2),\"matrix\",0)\n# #   will run MINE on matrix(1:10,2),\n# #   assuming that each of the two rows\n# #   in the matrix is a variable.\n# ###########################################\n# rMINE <- function (\n#   data,\n#   output.prefix,\n#   style=c(\"master.variable\", \"all.pairs\", \"adjacent.pairs\", \"pairs.between\", \"one.pair\"),\n#   var1.id=NA,\n#   var2.id=NA,\n#   required.common.vals.fraction=0,\n#   max.num.boxes.exponent=0.6,\n#   notify.wait=100,\n#   num.clumps.factor=15,\n#   debug.level=0,\n#   gc.wait=Inf,\n#   job.id\n# ) {\n#   printHeader()\n#   \n#   if(missing(output.prefix))\n#     stop(\"you must specify output.prefix so that I'll know what to name the output file!\")\n#   \n#   params <- getParams(output.prefix, style, var1.id, var2.id, required.common.vals.fraction, max.num.boxes.exponent, notify.wait, num.clumps.factor, debug.level, gc.wait, job.id)\n#   \n#   # run the analysis\n#   cat(\"reading in dataset...\\n\")\n#   flush.console()\n#   \n#   data <- .jarray(data, dispatch=TRUE)\n#   \n#   dataset <- .jnew(\"data/Dataset\",\n#                    data, params$analysisParams$mineParams$debug)\n#   cat(\"done.\\n\")\n#   flush.console()\n#   \n#   doAnalysis(dataset, params)\n# }\n# \n# printHeader <- function () {\n#   # print header\n#   cat(J(\"main/Analyze\")$header())\n#   cat(\"\\n\\n\")\n#   flush.console()\n# }\n# \n# getParams <- function(\n#   input.filename,\n#   style=c(\"master.variable\", \"all.pairs\", \"adjacent.pairs\", \"pairs.between\", \"one.pair\"),\n#   var1.id=NA,\n#   var2.id=NA,\n#   required.common.vals.fraction=0,\n#   max.num.boxes.exponent=0.6,\n#   notify.wait=100,\n#   num.clumps.factor=15,\n#   debug.level=0,\n#   gc.wait=Inf,\n#   job.id\n# ) {\n#   if (gc.wait==Inf) gc.wait <- J(\"java.lang.Integer\")$MAX_VALUE\n#   else gc.wait <- as.integer(gc.wait)\n#   \n#   # create parameters object  \n#   if(missing(job.id)) {\n#     args <- .jarray(c(\n#       input.filename,\n#       style,\n#       var1.id,\n#       var2.id,\n#       paste(\"cv=\", required.common.vals.fraction, sep = \"\"),\n#       paste(\"exp=\", max.num.boxes.exponent, sep = \"\"),\n#       paste(\"notify=\", notify.wait, sep = \"\"),\n#       paste(\"c=\", num.clumps.factor, sep = \"\"),\n#       paste(\"d=\", debug.level, sep = \"\"),\n#       paste(\"gc=\", gc.wait, sep = \"\")\n#     ))\n#   } else {\n#     args <- .jarray(c(\n#       input.filename,\n#       style,\n#       var1.id,\n#       var2.id,\n#       paste(\"cv=\", required.common.vals.fraction, sep = \"\"),\n#       paste(\"exp=\", max.num.boxes.exponent, sep = \"\"),\n#       paste(\"notify=\", notify.wait, sep = \"\"),\n#       paste(\"c=\", num.clumps.factor, sep = \"\"),\n#       paste(\"d=\", debug.level, sep = \"\"),\n#       paste(\"gc=\", gc.wait, sep = \"\"),\n#       paste(\"id=\", job.id, sep = \"\")\n#     ))\n#   }\n#   \n#   params <- .jnew(\"main/JobParameters\", args)\n#   flush.console()\n#   \n#   #confirm parameters for user\n#   cat(params$toString())\n#   cat(\"\\n\")\n#   flush.console()\n#   \n#   params\n# }\n# \n# doAnalysis <- function (dataset, params) {\n#   toAnalyze <- .jnew(\"analysis/VarPairQueue\", dataset)\n#   \n#   params$analysisStyle$addVarPairsTo(toAnalyze, dataset$numVariables())\n#   \n#   a <- .jnew(\"analysis/Analysis\", dataset, toAnalyze)\n#   \n#   cat(\"Analyzing...\\n\")\n#   flush.console()\n#   \n#   while(! a$varPairQueue()$isEmpty()) {\n#     # print a status update\n#     statusUpdate <- paste(a$numResults() + 1, \" calculating: \", a$varPairQueue()$peek()$var1$name(), \" vs \", a$varPairQueue()$peek()$var2$name(), \"...\\n\", sep=\"\")\n#     cat(statusUpdate)\n#     flush.console()\n#     \n#     # create a file containing the status update (for use when running on a cluster)\n#     write(statusUpdate, file=params$statusFileName())\n#     \n#     # analyze some more pairs\n#     a$analyzePairs(J(\"analysis.results/BriefResult\")$class,\n#                    params$analysisParams,\n#                    params$notifyWait)\n#   }\n#   \n#   cat(paste(a$numResults(), \" variable pairs analyzed.\\n\", \"Sorting results in descending order...\\n\", sep=\"\"))\n#   flush.console()\n#   \n#   results <- a$getSortedResults()\n#   \n#   cat(\"done. printing results\\n\")\n#   flush.console()\n#   \n#   #print the results\n#   repeat {\n#     if(J(\"main/Analyze\")$printResults(results, params)) {\n#       break\n#     }\n#     else {\n#       n <- readline(\"writing results to output file failed. Perhaps it is locked in some way. Enter 1 to try again, 0 otherwise: \")\n#       if(n == 0) break\n#     }\t\t\t\n#   }\n#   \n#   cat(\"Analysis finished. See file \\\"\")\n#   cat(params$resultsFileName())\n#   cat(\"\\\" for output\\n\")\n# }\n###########################################################end MINE.R####################################################\n\n\n# miRNA target prediction with the Maximal Information Coefficient (MIC) method\n# #  \n# # Calculate the MIC value of each pair of miRNA-mRNA, and return a matrix of values with columns are miRNAs and rows are mRNAs.\n# # Users need to download the file MINE.jar from nugget.unisa.edu.au/Thuc/miRLAB/ (this file was obtained from the paper of Reshef et al.)\n# # and place it in the working directory.\n# # @importFrom rJava .jnew .jarray J .jinit\n# # @param datacsv the input dataset in csv format\n# # @param separateIndex  the column index that separates the causes (the first half) and the effects (the second half)\n# # @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n# # If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n# # @return A  matrix that includes the MIC values. Columns are miRNAs, rows are mRNAs.\n# # @examples \n# # dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n# # results=MIC(dataset, 3) \n# # @references\n# # 1. Le, T.D., Liu, L., Zhang, J., Liu, B. and Li, J. (2014) From miRNA regulation to miRNA-TF co-regulation: computational approaches and challenges. Brief Bioinform., pii: bbu023.\n# # \n# # 2. Reshef, D.N., Reshef, Y.A., Finucane, H.K., Grossman, S.R., McVean, G., Turnbaugh, P.J., Lander, E.S., Mitzenmacher, M. and Sabeti, P.C. (2011) Detecting novel associations in large data sets. Science, 334, 1518-24.\n# # @export \n# ## 8. MIC(Maximal Information Coefficient) ##\n# MIC=function(datacsv, separateIndex, targetbinding=NA){  #add a line in MINE.R to increase java heaps\n#   #library(rJava)\n# \tdata=Read(datacsv)\n#         data=scale(data) #standardise the data\n#         header<-readHeader(datacsv)\n#         num_miRNA<-separateIndex\n#         miR<-header[1:num_miRNA]\n#         mR<-header[-(1:num_miRNA)]\n# \n# \tallnames=colnames(data)\n#   cause=1:separateIndex\n#   effect=(separateIndex+1):length(allnames)\n# \tcausenames=allnames[1:separateIndex]\n# \teffectnames=allnames[(separateIndex+1):length(allnames)]\n# \tres=matrix(nrow=length(effectnames), ncol=length(causenames))\n# \t\n# \tcolnames(res)=causenames\n# \trownames(res)=effectnames\n# \t#source(\"MINE.R\")\n# \t\t\n# \tMINE(datacsv, \"pairs.between\", separateIndex)\n# \tfilename=paste(datacsv, \",between[break=\", separateIndex, \"],cv=0.0,B=n^0.6,Results.csv\", sep=\"\")\n# \tresult=read.csv(filename, header=TRUE, sep=\",\")\n# \tfor(i in 1:nrow(result)){\n# \t\tres[result[i,2],result[i,1]]=result[i,3]\n# \t}\n# \n# if(is.na(targetbinding)==FALSE){\n# #query knowledge matrix from file\n# edgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \n# edgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\n# edgeTargetScan<-edgeTargetScan!=0;\n# edge=edgeTargetScan[effect,cause]\n# res=res*edge\n# }\n# \t\n# return(res)\n# }",
    "created" : 1433420079428.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1610891629",
    "id" : "E569D33F",
    "lastKnownWriteTime" : 1433420153,
    "path" : "~/Dropbox/PROJECTS-WORKING/miRLAB-APPLICATION-NOTE/Project/BACKUP-miRLAB/MIC.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}