{
    "contents" : "# This file contains a collection of methods for inferring miRNA-mRNA regulatory relationships\n# Each method will take the dataset (.csv) as an input with the first n colomns are miRNAs \n# and the last m columns are mRNAs. Rows are samples. We need to specify the number of miRNAs in the dataset\n# and the index of the miRNA, i.e. column that contains the miNRA. Topk is the number of top k interactions we\n# would like to extract.\n\n###########################################################TCGAAssembler- Module_A.R#####################################\n#############################################################################\n\n# TCGA-Assembler : An open-source R program for downloading, processing and analyzing public TCGA data.\n# Copyright (C) <2014>  <Yitan Zhu>\n# This file is part of TCGA-Assembler.\n\n#  TCGA-Assembler is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n\n#  TCGA-Assembler is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n\n#  You should have received a copy of the GNU General Public License\n#  along with TCGA-Assembler.  If not, see <http://www.gnu.org/licenses/>.\n############################################################################  \n\n\n##############################################################################\n\n# TCGA-Assembler Version 1.0.3 Module A\n\n##############################################################################\n\n#' @import RCurl\n#' @import httr\n#' @import stringr\n\n\n\n\n\nDownloadRNASeqData <-function (traverseResultFile, saveFolderName, cancerType, assayPlatform, dataType = \"\", tissueType = NULL, inputPatientIDs = NULL, outputFileName = \"\")\n{\n  \n  options(warn=-1);\n  \n  writeLines(\"**********************************************************************************\");\n  writeLines(\"\");\n  writeLines(paste(\"Download Gene Expression data of \", cancerType, \" patients.\", sep = \"\"));\n  \n  # Check whether specific TCGA patient IDs are inputted. \n  if (!is.null(inputPatientIDs))\n  {\n    inputPatientIDs = toupper(gsub(pattern = \"\\\\.\", replacement = \"-\", x = inputPatientIDs));\n  }\n  \n  if ((outputFileName != \"\") & (!is.null(outputFileName)))\n  {\n    outputFileName = paste(outputFileName, \"__\", sep = \"\");\n  }  \n  \n  # load directory traverse result and create folder to store output files\n  writeLines(\"Load information of TCGA data files.\");\n  file_url=c() \n  dir_url=c()\n  upper_file_url=c()\n  load(traverseResultFile);  \n  dir.create(path = saveFolderName, recursive = TRUE);\n  if (assayPlatform == \"RNASeqV1\")\n  {\n    platform = c(\"illuminaga_rnaseq\", \"illuminahiseq_rnaseq\"); \n    Institution = c(\"unc.edu\", \"bcgsc.ca\");    \n  }\n  if (assayPlatform == \"RNASeqV2\")\n  {\n    platform = c(\"illuminaga_rnaseqv2\", \"illuminahiseq_rnaseqv2\"); \n    Institution = c(\"unc.edu\");    \n  }\n  if (assayPlatform == \"Microarray\")\n  {\n    platform = c(\"agilentg4502a_07_3\", \"ht_hg-u133a\", \"agilentg4502a_07_1\", \"agilentg4502a_07_2\", \"hg-u133_plus_2\");\n    Institution = c(\"unc.edu\", \"broad.mit.edu\", \"genome.wustl.edu\");\n    dataType = \"\";\n  }\n  \n  # For returning downloaded data\n  downloadedData = vector(\"list\", 0);     \n  dataIndex = 0;     \n  \n  # download RNASeqV2 data\n  if (assayPlatform == \"RNASeqV2\")\n  {\n    for (IDin in 1:length(Institution))\n    {\n      for (IDpl in 1:length(platform))\n      {\n        SpecificName = paste(cancerType, \"__\", Institution[IDin], \"__\", platform[IDpl], sep = \"\");\n        SpecificID = grep(pattern = toupper(paste(\"/\", cancerType, \"/cgcc/\", Institution[IDin], \"/\", platform[IDpl], \"/\", sep = \"\")), x = upper_file_url, ignore.case = FALSE);\n        RNALevel3ID = SpecificID[grep(pattern = toupper(\"Level_3\"), x = upper_file_url[SpecificID], ignore.case = FALSE)];\n        ind = SpecificID[grepEnd(pattern = toupper(\"sdrf\\\\.txt\"), x = upper_file_url[SpecificID], ignore.case = FALSE)];\n        if (length(ind) == 0)\n        {\n          next;\n        }\n        if (length(ind) > 1)\n        {\n          URL = GetNewestURL(AllURL = file_url[ind]);\n        }else{\n          URL = file_url[ind];\n        }\n        downloadResult = urlReadTable(url = URL);\n        if (downloadResult$errorFlag != 0)\n        {\n          next;\n        }\n        sdrf = toupper(downloadResult$data);\n        \n        level_3_filename_column = max(grep(pattern = \"Derived Data File\", x = sdrf[1, ], ignore.case = TRUE));\n        DataLevelColID = max(grep(pattern = \"Comment \\\\[TCGA Data Level]\", x = sdrf[1, ], ignore.case = TRUE));\n        ExtractNameColID = grep(pattern = \"Comment \\\\[TCGA Barcode]\", x = sdrf[1, ], ignore.case = TRUE);\n        RefGenomeColID = grep(pattern = \"Comment \\\\[Genome reference]\", x = sdrf[1, ], ignore.case = TRUE);\n        if (length(ExtractNameColID) == 0)\n        {\n          ExtractNameColID = min(grep(pattern = \"Extract Name\", x = sdrf[1, ], ignore.case = TRUE));          \n        }\n        colnames(sdrf) = sdrf[1, ];\n        sdrf = unique(sdrf[2:dim(sdrf)[1], , drop = FALSE]);\n        Level3_ID = sort(union(which(sdrf[, DataLevelColID] == \"LEVEL_3\"), which(sdrf[, DataLevelColID] == \"LEVEL 3\")), decreasing = FALSE);\n        if (length(Level3_ID) == 0)\n        {\n          next;\n        }\n        sdrf = sdrf[Level3_ID, c(ExtractNameColID, level_3_filename_column, RefGenomeColID), drop = FALSE];\n        sdrf = sdrf[!duplicated(sdrf[, 2]), , drop = FALSE];\n        \n        # Only keep the file information for the data types that should be downloaded.\n        keepID = c();\n        for (keep_i in 1:length(dataType))\n        {\n          keepID = c(keepID, grep(pattern = dataType[keep_i], x = sdrf[, 2], ignore.case = TRUE))\n        }\n        sdrf = sdrf[sort(unique(keepID), decreasing = FALSE), , drop = FALSE];\n        \n        # If specific patient TCGA barcodes are inputted, only download the specified samples.\n        if (!is.null(inputPatientIDs))\n        {\n          indInputPatientID = c();\n          for (i in 1:length(inputPatientIDs))\n          {\n            indInputPatientID = c(indInputPatientID, grepBeginning(pattern = toupper(inputPatientIDs[i]), x = sdrf[, 1], ignore.case = FALSE));\n          }\n          if (length(indInputPatientID) == 0)\n          {\n            next;\n          }else{\n            sdrf = sdrf[indInputPatientID, , drop = FALSE];\n          }\n        }\n        \n        # Download data of specified tissue\n        if (!is.null(tissueType))\n        {\n          SampleType = cbind(Options = c(\"TP\", \"TR\", \"TB\", \"TRBM\", \"TAP\", \"TM\", \"TAM\", \"THOC\", \"TBM\", \"NB\", \"NT\", \"NBC\", \"NEBV\", \"NBM\"),\n                             Code = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\", \"13\", \"14\"));  \n          sdrf = sdrf[substr(sdrf[, 1], 14, 15) %in% SampleType[SampleType[, \"Options\"] %in% tissueType, \"Code\"], , drop = FALSE];\n        }\n        \n        if (dim(sdrf)[1] == 0)\n        {\n          next;\n        }\n        \n        # Start to download data files\n        exp_gene = NULL;\n        column_gene = NULL;\n        gene_left_column = NULL;\n        gene_data = NULL;\n        exp_gene_normalized = NULL;\n        column_gene_normalized = NULL;\n        gene_normalized_left_column = NULL;\n        gene_normalized_data = NULL;    \n        \n        exp_isoform = NULL;\n        column_isoform = NULL;\n        isoform_left_column = NULL;\n        isoform_data = NULL;\n        exp_isoform_normalized = NULL;\n        column_isoform_normalized = NULL;\n        isoform_normalized_left_column = NULL;\n        isoform_normalized_data = NULL;    \n        \n        exp_exon = NULL;\n        column_exon = NULL;\n        exon_left_column = NULL;\n        exon_data=NULL;\n        exp_junction = NULL;\n        column_junction = NULL;\n        junction_left_column = NULL;\n        junction_data=NULL;\n        \n        for (i in 1:dim(sdrf)[1])\n        {\n          time1 = proc.time();\n          \n          sample_TCGA_id = sdrf[i, 1];\n          ind = RNALevel3ID[grepEnd(pattern = sdrf[i, 2], x = upper_file_url[RNALevel3ID], ignore.case = FALSE)];\n          if (length(ind) == 0)\n          {\n            next;\n          }\n          if (length(ind) > 1)\n          {\n            URL = GetNewestURL(AllURL = file_url[ind]);\n          }else{\n            URL = file_url[ind];\n          }  \n          downloadResult = urlReadTable(url = URL);\n          if (downloadResult$errorFlag != 0)\n          {\n            next;\n          }\n          s = downloadResult$data;\n          \n          # read gene expression data\n          for (jj in 1:1)\n          {\n            if (length(grep(pattern = toupper(\"rsem.genes.results\"), x = sdrf[i, 2], ignore.case = FALSE)) > 0)\n            {\n              s = s[2:dim(s)[1], , drop = FALSE];\n              I_order_probes = order(s[, 1], decreasing = FALSE);\n              s = s[I_order_probes, , drop = FALSE];\n              if (is.null(gene_left_column))\n              {\n                gene_left_column = s[, c(1, 4), drop = FALSE];\n                gene_data = s[, c(2, 3), drop = FALSE];\n                exp_gene = c(sample_TCGA_id, sample_TCGA_id);\n                column_gene = c(\"raw_count\", \"scaled_estimate\");\n              }else{\n                if (sum(gene_left_column[, 1] != s[, 1]) > 0)\n                {\n                  next;\n                }\n                gene_data = cbind(gene_data, s[, c(2, 3), drop = FALSE]);\n                exp_gene = c(exp_gene, sample_TCGA_id, sample_TCGA_id);\n                column_gene = c(column_gene, \"raw_count\", \"scaled_estimate\");\n              }\n            }\n          }\n          \n          # read gene normalized data\n          for (jj in 1:1)\n          {\n            if (length(grep(pattern = toupper(\"rsem.genes.normalized_results\"), x = sdrf[i, 2], ignore.case = FALSE)) > 0)\n            {\n              s = s[2:dim(s)[1], , drop = FALSE];\n              I_order_probes = order(s[, 1], decreasing = FALSE);\n              s = s[I_order_probes, , drop = FALSE];\n              if (is.null(gene_normalized_left_column))\n              {\n                gene_normalized_left_column = s[, 1, drop = FALSE];\n                gene_normalized_data = s[, 2, drop = FALSE];\n                exp_gene_normalized = sample_TCGA_id;\n                column_gene_normalized = \"normalized_count\";\n              }else{\n                if (sum(gene_normalized_left_column[, 1] != s[, 1]) > 0)\n                {\n                  next;\n                }\n                gene_normalized_data = cbind(gene_normalized_data, s[, 2, drop = FALSE]);\n                exp_gene_normalized = c(exp_gene_normalized, sample_TCGA_id);\n                column_gene_normalized = c(column_gene_normalized, \"normalized_count\");\n              }\n            }\n          }          \n          \n          # read isoform data\n          for (jj in 1:1)\n          {\n            if (length(grep(pattern = toupper(\"rsem.isoforms.results\"), x = sdrf[i, 2], ignore.case = FALSE)) > 0)\n            {\n              s = s[2:dim(s)[1], , drop = FALSE];\n              I_order_probes = order(s[, 1], decreasing = FALSE);\n              s = s[I_order_probes, , drop = FALSE];\n              if (is.null(isoform_left_column))\n              {\n                isoform_left_column = s[, 1, drop = FALSE];\n                isoform_data = s[, c(2, 3), drop = FALSE];\n                exp_isoform = c(sample_TCGA_id, sample_TCGA_id);\n                column_isoform = c(\"raw_count\", \"scaled_estimate\");\n              }else{\n                if (sum(isoform_left_column[, 1] != s[, 1]) > 0)\n                {\n                  next;\n                }\n                isoform_data = cbind(isoform_data, s[, c(2, 3), drop = FALSE]);\n                exp_isoform = c(exp_isoform, sample_TCGA_id, sample_TCGA_id);\n                column_isoform = c(column_isoform, \"raw_count\", \"scaled_estimate\");\n              }\n            }\n          }\n          \n          # read isoform normalized data\n          for (jj in 1:1)\n          {\n            if (length(grep(pattern = toupper(\"rsem.isoforms.normalized_results\"), x = sdrf[i, 2], ignore.case = FALSE)) > 0)\n            {\n              s = s[2:dim(s)[1], , drop = FALSE];\n              I_order_probes = order(s[, 1], decreasing = FALSE);\n              s = s[I_order_probes, , drop = FALSE];\n              if (is.null(isoform_normalized_left_column))\n              {\n                isoform_normalized_left_column = s[, 1, drop = FALSE];\n                isoform_normalized_data = s[, 2, drop = FALSE];\n                exp_isoform_normalized = sample_TCGA_id;\n                column_isoform_normalized = \"normalized_count\";\n              }else{\n                if (sum(isoform_normalized_left_column[, 1] != s[, 1]) > 0)\n                {\n                  next;\n                }\n                isoform_normalized_data = cbind(isoform_normalized_data, s[, 2, drop = FALSE]);\n                exp_isoform_normalized = c(exp_isoform_normalized, sample_TCGA_id);\n                column_isoform_normalized = c(column_isoform_normalized, \"normalized_count\");\n              }\n            }\n          }          \n          \n          # read exon data\n          for (jj in 1:1)\n          {\n            if (length(grep(pattern = toupper(\"exon_quantification\"), x = sdrf[i, 2], ignore.case = FALSE)) > 0)\n            {\n              s = s[2:dim(s)[1], , drop = FALSE];\n              I_order_probes = order(s[, 1], decreasing = FALSE);\n              s = s[I_order_probes, , drop = FALSE];\n              if (is.null(exon_left_column))\n              {\n                exon_left_column = s[, 1, drop = FALSE];\n                exon_data = s[, 2:4, drop = FALSE];\n                exp_exon = c(sample_TCGA_id, sample_TCGA_id, sample_TCGA_id);\n                column_exon = c(\"raw_counts\", \"median_length_normalized\", \"RPKM\");\n              }else{\n                if (sum(exon_left_column[, 1] != s[, 1]) > 0)\n                {\n                  next;\n                }\n                exon_data = cbind(exon_data, s[, 2:4, drop = FALSE]);\n                exp_exon = c(exp_exon, sample_TCGA_id, sample_TCGA_id, sample_TCGA_id);\n                column_exon = c(column_exon, \"raw_counts\", \"median_length_normalized\", \"RPKM\");\n              }\n            }\n          }\n          \n          # read junction data\n          for (jj in 1:1)\n          {\n            if (length(grep(pattern = toupper(\"junction_quantification\"), x = sdrf[i, 2], ignore.case = FALSE)) > 0)\n            {\n              s = s[2:dim(s)[1], , drop = FALSE];\n              I_order_probes = order(s[, 1], decreasing = FALSE);\n              s = s[I_order_probes, , drop = FALSE];\n              if (is.null(junction_left_column))\n              {\n                junction_left_column = s[, 1, drop = FALSE];\n                junction_data = s[, 2, drop = FALSE];\n                exp_junction = sample_TCGA_id;\n                column_junction = \"raw_counts\";\n              }else{\n                if (sum(junction_left_column[, 1] != s[, 1]) > 0)\n                {\n                  next;\n                }\n                junction_data = cbind(junction_data, s[, 2, drop = FALSE]);\n                exp_junction = c(exp_junction, sample_TCGA_id);\n                column_junction = c(column_junction, \"raw_counts\");\n              }\n            }\n          }          \n          \n          time = proc.time() - time1;\n          writeLines(paste(\"Downloaded - \", SpecificName, \" - file \", i, \" out of \", dim(sdrf)[1], \". \", round(time[3], digits = 1), \" seconds elapsed.\", sep = \"\"));\n        }\n        \n        writeLines(\"Save data to local disk.\");\n        ID = str_locate_all(traverseResultFile, \"_\")[[1]];\n        ID = ID[dim(ID)[1], 2];\n        if (length(grep(pattern = \"rsem.genes.results\", x = dataType, ignore.case = TRUE)) > 0)\n        {\n          filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__rsem.genes.results__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n          write.table(rbind(c(\"Hybridization REF\", \"Hybridization REF\", exp_gene), c(\"gene_id\", \"transcript_id\", column_gene), cbind(gene_left_column, gene_data)), \n                      file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE); \n          \n          # For returning downloaded data\n          dataIndex = dataIndex + 1\n          downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", \"Hybridization REF\", exp_gene), c(\"gene_id\", \"transcript_id\", column_gene), cbind(gene_left_column, gene_data));\n          names(downloadedData)[dataIndex] = paste(SpecificName, \"rsem.genes.results\", sep = \"__\");\n        }\n        if (length(grep(pattern = \"rsem.genes.normalized_results\", x = dataType, ignore.case = TRUE)) > 0)\n        {\n          filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__rsem.genes.normalized_results__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n          write.table(rbind(c(\"Hybridization REF\", exp_gene_normalized), c(\"gene_id\", column_gene_normalized), cbind(gene_normalized_left_column, gene_normalized_data)), \n                      file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE); \n          \n          # For returning downloaded data\n          dataIndex = dataIndex + 1          \n          downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", exp_gene_normalized), c(\"gene_id\", column_gene_normalized), cbind(gene_normalized_left_column, gene_normalized_data));\n          names(downloadedData)[dataIndex] = paste(SpecificName, \"rsem.genes.normalized_results\", sep = \"__\");\n        }\n        if (length(grep(pattern = \"rsem.isoforms.results\", x = dataType, ignore.case = TRUE)) > 0)\n        {\n          filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__rsem.isoforms.results__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n          write.table(rbind(c(\"Hybridization REF\", exp_isoform), c(\"isoform_id\", column_isoform), cbind(isoform_left_column, isoform_data)), \n                      file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE); \n          \n          # For returning downloaded data\n          dataIndex = dataIndex + 1          \n          downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", exp_isoform), c(\"isoform_id\", column_isoform), cbind(isoform_left_column, isoform_data));\n          names(downloadedData)[dataIndex] = paste(SpecificName, \"rsem.isoforms.results\", sep = \"__\");\n        }\n        if (length(grep(pattern = \"rsem.isoforms.normalized_results\", x = dataType, ignore.case = TRUE)) > 0)\n        {\n          filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__rsem.isoforms.normalized_results__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n          write.table(rbind(c(\"Hybridization REF\", exp_isoform_normalized), c(\"isoform_id\", column_isoform_normalized), cbind(isoform_normalized_left_column, isoform_normalized_data)), \n                      file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE);  \n          \n          # For returning downloaded data\n          dataIndex = dataIndex + 1          \n          downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", exp_isoform_normalized), c(\"isoform_id\", column_isoform_normalized), cbind(isoform_normalized_left_column, isoform_normalized_data));\n          names(downloadedData)[dataIndex] = paste(SpecificName, \"rsem.isoforms.normalized_results\", sep = \"__\");\n        }\n        if (length(grep(pattern = \"exon_quantification\", x = dataType, ignore.case = TRUE)) > 0)\n        {\n          filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__exon_quantification__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n          write.table(rbind(c(\"Hybridization REF\", exp_exon), c(\"exon\", column_exon), cbind(exon_left_column, exon_data)), \n                      file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE);\n          \n          # For returning downloaded data\n          dataIndex = dataIndex + 1          \n          downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", exp_exon), c(\"exon\", column_exon), cbind(exon_left_column, exon_data));\n          names(downloadedData)[dataIndex] = paste(SpecificName, \"exon_quantification\", sep = \"__\");\n        }\n        if (length(grep(pattern = \"junction_quantification\", x = dataType, ignore.case = TRUE)) > 0)\n        {\n          filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__junction_quantification__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n          write.table(rbind(c(\"Hybridization REF\", exp_junction), c(\"junction\", column_junction), cbind(junction_left_column, junction_data)), \n                      file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE); \n          \n          # For returning downloaded data\n          dataIndex = dataIndex + 1          \n          downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", exp_junction), c(\"junction\", column_junction), cbind(junction_left_column, junction_data));\n          names(downloadedData)[dataIndex] = paste(SpecificName, \"junction_quantification\", sep = \"__\");\n        }\n      }\n    }\n  }\n  \n  # download RNASeqV1 data\n  if (assayPlatform == \"RNASeqV1\")\n  {\n    for (IDin in 1:length(Institution))\n    {\n      for (IDpl in 1:length(platform))\n      {\n        SpecificName = paste(cancerType, \"__\", Institution[IDin], \"__\", platform[IDpl], sep = \"\");\n        SpecificID = grep(pattern = toupper(paste(\"/\", cancerType, \"/cgcc/\", Institution[IDin], \"/\", platform[IDpl], \"/\", sep = \"\")), x = upper_file_url, ignore.case = FALSE);\n        RNALevel3ID = SpecificID[grep(pattern = toupper(\"Level_3\"), x = upper_file_url[SpecificID], ignore.case = FALSE)];\n        ind = SpecificID[grepEnd(pattern = toupper(\"sdrf\\\\.txt\"), x = upper_file_url[SpecificID], ignore.case = FALSE)];\n        if (length(ind) == 0)\n        {\n          next;\n        }\n        if (length(ind) > 1)\n        {\n          URL = GetNewestURL(AllURL = file_url[ind]);\n        }else{\n          URL = file_url[ind];\n        }\n        downloadResult = urlReadTable(url = URL);\n        if (downloadResult$errorFlag != 0)\n        {\n          next;\n        }\n        sdrf = toupper(downloadResult$data);\n        \n        level_3_filename_column = max(grep(pattern = \"Derived Data File\", x = sdrf[1, ], ignore.case = TRUE));\n        DataLevelColID = max(grep(pattern = \"Comment \\\\[TCGA Data Level]\", x = sdrf[1, ], ignore.case = TRUE));\n        ExtractNameColID = grep(pattern = \"Comment \\\\[TCGA Barcode]\", x = sdrf[1, ], ignore.case = TRUE);\n        RefGenomeColID = grep(pattern = \"Comment \\\\[Genome reference]\", x = sdrf[1, ], ignore.case = TRUE);\n        if (length(ExtractNameColID) == 0)\n        {\n          ExtractNameColID = min(grep(pattern = \"Extract Name\", x = sdrf[1, ], ignore.case = TRUE));          \n        }\n        colnames(sdrf) = sdrf[1, ];\n        sdrf = unique(sdrf[2:dim(sdrf)[1], , drop = FALSE]);\n        Level3_ID = sort(union(which(sdrf[, DataLevelColID] == \"LEVEL_3\"), which(sdrf[, DataLevelColID] == \"LEVEL 3\")), decreasing = FALSE);\n        if (length(Level3_ID) == 0)\n        {\n          next;\n        }\n        sdrf = sdrf[Level3_ID, c(ExtractNameColID, level_3_filename_column, RefGenomeColID), drop = FALSE];\n        sdrf = sdrf[!duplicated(sdrf[, 2]), , drop = FALSE];\n        \n        # Only keep the file information for the data types that should be downloaded.\n        keepID = c();\n        for (keep_i in 1:length(dataType))\n        {\n          keepID = c(keepID, grep(pattern = dataType[keep_i], x = sdrf[, 2], ignore.case = TRUE))\n        }\n        sdrf = sdrf[sort(unique(keepID), decreasing = FALSE), , drop = FALSE];\n        \n        # If specific patient TCGA barcodes are inputted, only download the specified samples.\n        if (!is.null(inputPatientIDs))\n        {\n          indInputPatientID = c();\n          for (i in 1:length(inputPatientIDs))\n          {\n            indInputPatientID = c(indInputPatientID, grepBeginning(pattern = toupper(inputPatientIDs[i]), x = sdrf[, 1], ignore.case = FALSE));\n          }\n          if (length(indInputPatientID) == 0)\n          {\n            next;\n          }else{\n            sdrf = sdrf[indInputPatientID, , drop = FALSE];\n          }\n        }\n        \n        # Download data of specified tissue\n        if (!is.null(tissueType))\n        {\n          SampleType = cbind(Options = c(\"TP\", \"TR\", \"TB\", \"TRBM\", \"TAP\", \"TM\", \"TAM\", \"THOC\", \"TBM\", \"NB\", \"NT\", \"NBC\", \"NEBV\", \"NBM\"),\n                             Code = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\", \"13\", \"14\"));  \n          sdrf = sdrf[substr(sdrf[, 1], 14, 15) %in% SampleType[SampleType[, \"Options\"] %in% tissueType, \"Code\"], , drop = FALSE];\n        }\n        \n        if (dim(sdrf)[1] == 0)\n        {\n          next;\n        }\n        \n        exp_names_gene = NULL;\n        column_gene = NULL;\n        gene_left_column = NULL;\n        gene_RPKM = NULL;\n        \n        exp_names_exon = NULL;\n        column_exon = NULL;\n        exon_left_column = NULL;\n        exon_RPKM = NULL;\n        \n        junction_count = NULL;\n        exp_names_junction = NULL;    \n        column_junction = NULL;     \n        junction_left_column = NULL;        \n        \n        for (i in 1:dim(sdrf)[1])\n        {\n          time1 = proc.time();\n          \n          sample_TCGA_id = sdrf[i, 1];\n          ind = RNALevel3ID[grepEnd(pattern = sdrf[i, 2], x = upper_file_url[RNALevel3ID], ignore.case = FALSE)];\n          if (length(ind) == 0)\n          {\n            next;\n          }\n          if (length(ind) > 1)\n          {\n            URL = GetNewestURL(AllURL = file_url[ind]);\n          }else{\n            URL = file_url[ind];\n          }  \n          downloadResult = urlReadTable(url = URL);\n          if (downloadResult$errorFlag != 0)\n          {\n            next;\n          }\n          s = downloadResult$data;\n          \n          # read gene expression data\n          for (jj in 1:1)\n          {\n            if (length(grep(pattern = toupper(\"gene.quantification\"), x = sdrf[i, 2], ignore.case = FALSE)) > 0)\n            {\n              s = s[2:dim(s)[1], , drop = FALSE];\n              I_order_probes = order(s[, 1], decreasing = FALSE);\n              s = s[I_order_probes, , drop = FALSE];\n              if (is.null(gene_left_column))\n              {\n                gene_left_column = s[, 1, drop = FALSE];\n                gene_RPKM = s[, 2:4, drop = FALSE];\n                exp_names_gene = c(sample_TCGA_id, sample_TCGA_id, sample_TCGA_id);\n                column_gene = c(\"raw_counts\", \"median_length_normalized\", \"RPKM\");\n              }else{\n                if (sum(gene_left_column[, 1] != s[, 1]) > 0)\n                {\n                  next;\n                }\n                gene_RPKM = cbind(gene_RPKM, s[, 2:4, drop = FALSE]);\n                exp_names_gene = c(exp_names_gene, sample_TCGA_id, sample_TCGA_id, sample_TCGA_id);\n                column_gene = c(column_gene, \"raw_counts\", \"median_length_normalized\", \"RPKM\");\n              }\n            }\n          }\n          \n          # read exon expression data\n          for (jj in 1:1)\n          {\n            if (length(grep(pattern = toupper(\"exon.quantification\"), x = sdrf[i, 2], ignore.case = FALSE)) > 0)\n            {\n              s = s[2:dim(s)[1], , drop = FALSE];\n              I_order_probes = order(s[, 1], decreasing = FALSE);\n              s = s[I_order_probes, , drop = FALSE];\n              if (is.null(exon_left_column))\n              {\n                exon_left_column = s[, 1, drop = FALSE];\n                exon_RPKM = s[, 2:4, drop = FALSE];\n                exp_names_exon = c(sample_TCGA_id, sample_TCGA_id, sample_TCGA_id);\n                column_exon = c(\"raw_counts\", \"median_length_normalized\", \"RPKM\");\n              }else{\n                if (sum(exon_left_column[, 1] != s[, 1]) > 0)\n                {\n                  next;\n                }\n                exon_RPKM = cbind(exon_RPKM, s[, 2:4, drop = FALSE]);\n                exp_names_exon = c(exp_names_exon, sample_TCGA_id, sample_TCGA_id, sample_TCGA_id);\n                column_exon = c(column_exon, \"raw_counts\", \"median_length_normalized\", \"RPKM\");\n              }\n            }\n          }\n          \n          # read junction expression data\n          for (jj in 1:1)\n          {\n            if (length(grep(pattern = toupper(\"spljxn.quantification\"), x = sdrf[i, 2], ignore.case = FALSE)) > 0)\n            {\n              s = s[2:dim(s)[1], , drop = FALSE];\n              I_order_probes = order(s[, 1], decreasing = FALSE);\n              s = s[I_order_probes, , drop = FALSE];\n              if (is.null(junction_left_column))\n              {\n                junction_left_column = s[, 1, drop = FALSE];\n                junction_count = s[, 2, drop = FALSE];\n                exp_names_junction = sample_TCGA_id;\n                column_junction = \"raw_counts\";\n              }else{\n                if (sum(junction_left_column[, 1] != s[, 1]) > 0)\n                {\n                  next;\n                }\n                junction_count = cbind(junction_count, s[, 2, drop = FALSE]);\n                exp_names_junction = c(exp_names_junction, sample_TCGA_id);\n                column_junction = c(column_junction, \"raw_counts\");\n              }\n            }\n          }\n          \n          time = proc.time() - time1;\n          writeLines(paste(\"Downloaded - \", SpecificName, \" - file \", i, \" out of \", dim(sdrf)[1], \". \", round(time[3], digits = 1), \" seconds elapsed.\", sep = \"\"));\n        }\n        \n        writeLines(\"Save data to local disk.\");\n        ID = str_locate_all(traverseResultFile, \"_\")[[1]];\n        ID = ID[dim(ID)[1], 2];\n        if (length(grep(pattern = \"gene.quantification\", x = dataType, ignore.case = TRUE)) > 0)\n        {\n          filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__gene.quantification__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n          write.table(rbind(c(\"Hybridization REF\", exp_names_gene), c(\"gene\", column_gene), cbind(gene_left_column, gene_RPKM)), \n                      file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE);  \n          \n          # For returning downloaded data\n          dataIndex = dataIndex + 1;          \n          downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", exp_names_gene), c(\"gene\", column_gene), cbind(gene_left_column, gene_RPKM));\n          names(downloadedData)[dataIndex] = paste(SpecificName, \"gene.quantification\", sep = \"__\");\n        }\n        if (length(grep(pattern = \"exon.quantification\", x = dataType, ignore.case = TRUE)) > 0)\n        {\n          filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__exon.quantification__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n          write.table(rbind(c(\"Hybridization REF\", exp_names_exon), c(\"exon\", column_exon), cbind(exon_left_column, exon_RPKM)), \n                      file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE);  \n          \n          # For returning downloaded data\n          dataIndex = dataIndex + 1;\n          downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", exp_names_exon), c(\"exon\", column_exon), cbind(exon_left_column, exon_RPKM));\n          names(downloadedData)[dataIndex] = paste(SpecificName, \"exon.quantification\", sep = \"__\");          \n        }\n        if (length(grep(pattern = \"spljxn.quantification\", x = dataType, ignore.case = TRUE)) > 0)\n        {\n          filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__spljxn.quantification__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n          write.table(rbind(c(\"Hybridization REF\", exp_names_junction), c(\"junction\", column_junction), cbind(junction_left_column, junction_count)), \n                      file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE);  \n          \n          # For returning downloaded data\n          dataIndex = dataIndex + 1;\n          downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", exp_names_junction), c(\"junction\", column_junction), cbind(junction_left_column, junction_count));\n          names(downloadedData)[dataIndex] = paste(SpecificName, \"spljxn.quantification\", sep = \"__\");             \n        }\n      }\n    }\n  }\n  \n  # download Microarray data\n  if (assayPlatform == \"Microarray\")\n  {\n    for (IDin in 1:length(Institution))\n    {\n      for (IDpl in 1:length(platform))\n      {\n        \n        SpecificName = paste(cancerType, \"__\", Institution[IDin], \"__\", platform[IDpl], sep = \"\");\n        SpecificID = grep(pattern = toupper(paste(\"/\", cancerType, \"/cgcc/\", Institution[IDin], \"/\", platform[IDpl], \"/\", sep = \"\")), x = upper_file_url, ignore.case = FALSE);\n        RNALevel3ID = SpecificID[grep(pattern = toupper(\"Level_3\"), x = upper_file_url[SpecificID], ignore.case = FALSE)];\n        ind = SpecificID[grepEnd(pattern = toupper(\"sdrf\\\\.txt\"), x = upper_file_url[SpecificID], ignore.case = FALSE)];\n        if (length(ind) == 0)\n        {\n          next;\n        }\n        if (length(ind) > 1)\n        {\n          URL = GetNewestURL(AllURL = file_url[ind]);\n        }else{\n          URL = file_url[ind];\n        }\n        downloadResult = urlReadTable(url = URL);\n        if (downloadResult$errorFlag != 0)\n        {\n          next;\n        }\n        sdrf = toupper(downloadResult$data);\n        \n        # Derived Array Data Matrix File\n        level_3_filename_column = max(grep(pattern = \"Derived Array Data Matrix File\", x = sdrf[1, ], ignore.case = TRUE));\n        DataLevelColID = max(grep(pattern = \"Comment \\\\[TCGA Data Level]\", x = sdrf[1, ], ignore.case = TRUE));\n        ExtractNameColID = grep(pattern = \"Comment \\\\[TCGA Barcode]\", x = sdrf[1, ], ignore.case = TRUE);\n        if (length(ExtractNameColID) == 0)\n        {\n          ExtractNameColID = min(grep(pattern = \"Extract Name\", x = sdrf[1, ], ignore.case = TRUE));          \n        }\n        colnames(sdrf) = sdrf[1, ];\n        sdrf = unique(sdrf[2:dim(sdrf)[1], , drop = FALSE]);\n        Level3_ID = sort(union(which(sdrf[, DataLevelColID] == \"LEVEL_3\"), which(sdrf[, DataLevelColID] == \"LEVEL 3\")), decreasing = FALSE);\n        if (length(Level3_ID) == 0)\n        {\n          next;\n        }\n        sdrf = sdrf[Level3_ID, c(ExtractNameColID, level_3_filename_column), drop = FALSE];\n        sdrf = sdrf[!duplicated(sdrf[, 2]), , drop = FALSE];\n        \n        # If specific patient TCGA barcodes are inputted, only download the specified samples.\n        if (!is.null(inputPatientIDs))\n        {\n          indInputPatientID = c();\n          for (i in 1:length(inputPatientIDs))\n          {\n            indInputPatientID = c(indInputPatientID, grepBeginning(pattern = toupper(inputPatientIDs[i]), x = sdrf[, 1], ignore.case = FALSE));\n          }\n          if (length(indInputPatientID) == 0)\n          {\n            next;\n          }else{\n            sdrf = sdrf[indInputPatientID, , drop = FALSE];\n          }\n        }\n        \n        # Download data of specified tissue\n        if (!is.null(tissueType))\n        {\n          SampleType = cbind(Options = c(\"TP\", \"TR\", \"TB\", \"TRBM\", \"TAP\", \"TM\", \"TAM\", \"THOC\", \"TBM\", \"NB\", \"NT\", \"NBC\", \"NEBV\", \"NBM\"),\n                             Code = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\", \"13\", \"14\"));  \n          sdrf = sdrf[substr(sdrf[, 1], 14, 15) %in% SampleType[SampleType[, \"Options\"] %in% tissueType, \"Code\"], , drop = FALSE];\n        }\n        \n        if (dim(sdrf)[1] == 0)\n        {\n          next;\n        }\n        \n        exp_names_gene = NULL;\n        column_gene = NULL;\n        gene_left_column = NULL;\n        gene_RPKM = NULL;\n        for (i in 1:dim(sdrf)[1])\n        {\n          time1 = proc.time();\n          \n          sample_TCGA_id = sdrf[i, 1];\n          ind = RNALevel3ID[grepEnd(pattern = sdrf[i, 2], x = upper_file_url[RNALevel3ID], ignore.case = FALSE)];\n          if (length(ind) == 0)\n          {\n            next;\n          }\n          if (length(ind) > 1)\n          {\n            URL = GetNewestURL(AllURL = file_url[ind]);\n          }else{\n            URL = file_url[ind];\n          }  \n          downloadResult = urlReadTable(url = URL);\n          if (downloadResult$errorFlag != 0)\n          {\n            next;\n          }\n          s = downloadResult$data;\n          \n          column_gene = c(column_gene, s[2, 2]);\n          s = s[3:dim(s)[1], , drop = FALSE];\n          I_order_probes = order(s[, 1], decreasing = FALSE);\n          s = s[I_order_probes, , drop = FALSE];\n          if (is.null(gene_left_column))\n          {\n            gene_left_column = s[, 1, drop = FALSE];\n            gene_RPKM = s[, 2, drop = FALSE];\n            exp_names_gene = c(sample_TCGA_id);\n          }else{\n            if (sum(gene_left_column[, 1] != s[, 1]) > 0)\n            {\n              next;\n            }\n            gene_RPKM = cbind(gene_RPKM, s[, 2, drop = FALSE]);\n            exp_names_gene = c(exp_names_gene, sample_TCGA_id);\n          }\n          \n          time = proc.time() - time1;\n          writeLines(paste(\"Downloaded - \", SpecificName, \" - file \", i, \" out of \", dim(sdrf)[1], \". \", round(time[3], digits = 1), \" seconds elapsed.\", sep = \"\"));\n        }\n        \n        writeLines(\"Save data to local disk.\");\n        ID = str_locate_all(traverseResultFile, \"_\")[[1]];\n        ID = ID[dim(ID)[1], 2];\n        filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__gene.quantification__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n        write.table(rbind(c(\"Hybridization REF\", exp_names_gene), c(\"Composite Element REF\", column_gene), cbind(gene_left_column, gene_RPKM)), \n                    file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE);  \n        \n        # For returning downloaded data\n        dataIndex = dataIndex + 1;          \n        downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", exp_names_gene), c(\"Composite Element REF\", column_gene), cbind(gene_left_column, gene_RPKM));\n        names(downloadedData)[dataIndex] = paste(SpecificName, \"gene.quantification\", sep = \"__\");\n        \n      }\n    }\n  }\n  \n  writeLines(\"\");\n  writeLines(\"**********************************************************************************\");\n  writeLines(\"\\n\");\n  \n  options(warn=0);\n  \n  # Return downloaded data\n  if (length(downloadedData) > 0)\n  {\n    for (i in 1:length(downloadedData))\n    {\n      rownames(downloadedData[[i]]) = NULL;\n      colnames(downloadedData[[i]]) = NULL;\n    }\n  }\n  downloadedData;\n}\n\n\n\n\nDownloadmiRNASeqData <- function(traverseResultFile, saveFolderName, cancerType, assayPlatform = \"miRNASeq\", tissueType = NULL, inputPatientIDs = NULL, outputFileName = \"\")\n{\n  options(warn=-1);\n  \n  writeLines(\"**********************************************************************************\");\n  writeLines(\"\");\n  writeLines(paste(\"Download miRNA-seq data of \", cancerType, \" patients.\", sep = \"\"));\n  \n  # Check whether specific TCGA patient IDs are inputted. \n  if (!is.null(inputPatientIDs))\n  {\n    inputPatientIDs = toupper(gsub(pattern = \"\\\\.\", replacement = \"-\", x = inputPatientIDs));\n  }  \n  \n  if ((outputFileName != \"\") & (!is.null(outputFileName)))\n  {\n    outputFileName = paste(outputFileName, \"__\", sep = \"\");\n  }\n  \n  # For returning downloaded data\n  downloadedData = vector(\"list\", 0);     \n  dataIndex = 0;     \n  \n  # load directory traverse result and create folder to store output files\n  writeLines(\"Load information of TCGA data files.\");\n  file_url=c()\n  upper_file_url=c()\n  load(traverseResultFile);\n  if (assayPlatform == \"miRNASeq\")\n  {\n    platform = c(\"illuminaga_mirnaseq\", \"illuminahiseq_mirnaseq\");\n  }\n  dir.create(path = saveFolderName, recursive = TRUE);\n  miRNALevel3ID = grep(pattern = toupper(\"miRNASeq\\\\.Level_3\"), x = upper_file_url, ignore.case = FALSE);\n  \n  for (IDpl in 1:length(platform))\n  {\n    SpecificName = paste(cancerType, \"__\", \"bcgsc.ca\", \"__\", platform[IDpl], sep = \"\");\n    SpecificID = grep(pattern = toupper(paste(\"/\", cancerType, \"/cgcc/bcgsc\\\\.ca/\", platform[IDpl], sep = \"\")), x = upper_file_url, ignore.case = FALSE);\n    ind = SpecificID[grepEnd(pattern = toupper(\"sdrf\\\\.txt\"), x = upper_file_url[SpecificID], ignore.case = FALSE)];\n    if (length(ind) == 0)\n    {\n      next;\n    }\n    if (length(ind) > 1)\n    {\n      URL = GetNewestURL(AllURL = file_url[ind]);\n    }else{\n      URL = file_url[ind];\n    }  \n    downloadResult = urlReadTable(url = URL);\n    if (downloadResult$errorFlag != 0)\n    {\n      next;\n    }\n    sdrf = toupper(downloadResult$data);  \n    \n    # Process SDRF file, identify the columns of level 3 data file name and TCGA sample barcodes.\n    level_3_filename_column = max(grep(pattern = \"Derived Data File\", x = sdrf[1, ], ignore.case = TRUE));\n    DataLevelColID = max(grep(pattern = \"Comment \\\\[TCGA Data Level]\", x = sdrf[1, ], ignore.case = TRUE));\n    ExtractNameColID = min(grep(pattern = \"Comment \\\\[TCGA Barcode]\", x = sdrf[1, ], ignore.case = TRUE));\n    RefGenomeColID = grep(pattern = \"Comment \\\\[Genome reference]\", x = sdrf[1, ], ignore.case = TRUE);\n    if (length(ExtractNameColID) == 0)\n    {\n      ExtractNameColID = min(grep(pattern = \"Extract Name\", x = sdrf[1, ], ignore.case = TRUE));\n    }\n    colnames(sdrf) = sdrf[1, ];\n    sdrf = unique(sdrf[2:dim(sdrf)[1], , drop = FALSE]);\n    sdrf = sdrf[!duplicated(sdrf[, level_3_filename_column]), , drop = FALSE];\n    \n    Level3_ID = sort(union(which(sdrf[, DataLevelColID] == \"LEVEL_3\"), which(sdrf[, DataLevelColID] == \"LEVEL 3\")), decreasing = FALSE);\n    Level3_ID = sort(intersect(Level3_ID, grep(pattern = toupper(\"mirna\\\\.quantification\"), \n                                               x = sdrf[, level_3_filename_column], ignore.case = FALSE)), decreasing = FALSE);\n    if (length(Level3_ID) == 0)\n    {\n      next;\n    }\n    sdrf = sdrf[Level3_ID, c(ExtractNameColID, level_3_filename_column, RefGenomeColID), drop = FALSE];    \n    \n    # If specific patient TCGA barcodes are inputted, only download the specified samples.\n    if (!is.null(inputPatientIDs))\n    {\n      indInputPatientID = c();\n      for (i in 1:length(inputPatientIDs))\n      {\n        indInputPatientID = c(indInputPatientID, grepBeginning(pattern = toupper(inputPatientIDs[i]), x = sdrf[, 1], ignore.case = FALSE));\n      }\n      if (length(indInputPatientID) == 0)\n      {\n        next;      \n      }else{\n        sdrf = sdrf[indInputPatientID, , drop = FALSE];\n      }\n    }\n    \n    # Download data of specified tissue\n    if (!is.null(tissueType))\n    {\n      SampleType = cbind(Options = c(\"TP\", \"TR\", \"TB\", \"TRBM\", \"TAP\", \"TM\", \"TAM\", \"THOC\", \"TBM\", \"NB\", \"NT\", \"NBC\", \"NEBV\", \"NBM\"),\n                         Code = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\", \"13\", \"14\"));  \n      sdrf = sdrf[substr(sdrf[, 1], 14, 15) %in% SampleType[SampleType[, \"Options\"] %in% tissueType, \"Code\"], , drop = FALSE];\n    }\n    \n    if (dim(sdrf)[1] == 0)\n    {\n      next;\n    }\n    \n    sdrfO = sdrf;\n    for (RefGId in 1:2)\n    {\n      if (RefGId == 1)\n      {\n        sdrf = sdrfO[grep(pattern = toupper(\"NCBI36\"), x = sdrfO[, 3], ignore.case = FALSE), , drop = FALSE];  \n      }\n      if (RefGId == 2)\n      {\n        sdrf = sdrfO[grep(pattern = toupper(\"GRCh37\"), x = sdrfO[, 3], ignore.case = FALSE), , drop = FALSE];  \n      }\n      if (dim(sdrf)[1] == 0)\n      {\n        next;\n      }\n      \n      exp_names = NULL;\n      gene_left_column = NULL;\n      gene_RPM = NULL;\n      column_gene = NULL;\n      for (i in 1:dim(sdrf)[1])\n      {\n        time1 = proc.time();\n        \n        sample_TCGA_id = sdrf[i, 1];\n        ind = intersect(miRNALevel3ID, SpecificID[grepEnd(pattern = sdrf[i, 2], x = upper_file_url[SpecificID], ignore.case = FALSE)]);\n        if (length(ind) == 0)\n        {\n          next;\n        }\n        if (length(ind) > 1)\n        {\n          URL = GetNewestURL(AllURL = file_url[ind]);\n        }else{\n          URL = file_url[ind];\n        }  \n        downloadResult = urlReadTable(url = URL);\n        if (downloadResult$errorFlag != 0)\n        {\n          next;\n        }\n        s = downloadResult$data[2:dim(downloadResult$data)[1], , drop = FALSE];\n        I_order_probes = order(s[, 1], decreasing = FALSE);\n        s = s[I_order_probes, , drop = FALSE];\n        if (is.null(gene_left_column))\n        {\n          gene_left_column = s[, 1, drop = FALSE];\n          exp_names = c(sample_TCGA_id, sample_TCGA_id);\n          gene_RPM = s[, 2:3, drop = FALSE];\n          column_gene = c(\"read_count\", \"reads_per_million_miRNA_mapped\");\n        }else{\n          if (sum(gene_left_column[, 1] != s[ ,1]) > 0)\n          {\n            next;\n          }\n          exp_names = c(exp_names, sample_TCGA_id, sample_TCGA_id);\n          gene_RPM = cbind(gene_RPM, s[, 2:3, drop = FALSE]);\n          column_gene = c(column_gene, \"read_count\", \"reads_per_million_miRNA_mapped\");\n        }\n        \n        time = proc.time() - time1;\n        if (RefGId == 1)\n        {\n          writeLines(paste(\"Downloaded - \", SpecificName, \" - NCBI36 - sample \", i, \" out of \", dim(sdrf)[1], \". \", round(time[3], digits = 1), \" seconds elapsed.\", sep = \"\"));\n        }\n        if (RefGId == 2)\n        {\n          writeLines(paste(\"Downloaded - \", SpecificName, \" - GRCh37 - sample \", i, \" out of \", dim(sdrf)[1], \". \", round(time[3], digits = 1), \" seconds elapsed.\", sep = \"\"));\n        }\n        \n      }\n      \n      if (!is.null(gene_RPM))\n      {\n        writeLines(\"Save data to local disk.\");\n        ID = str_locate_all(traverseResultFile, \"_\")[[1]];\n        ID = ID[dim(ID)[1], 2];\n        if (RefGId == 1)\n        {\n          filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__NCBI36__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n          write.table(rbind(c(\"Hybridization REF\", exp_names), c(\"miRNA_ID\", column_gene), cbind(gene_left_column, gene_RPM)), file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE);  \n          \n          # For returning downloaded data\n          dataIndex = dataIndex+1;     \n          downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", exp_names), c(\"miRNA_ID\", column_gene), cbind(gene_left_column, gene_RPM));\n          rownames(downloadedData[[dataIndex]]) = NULL;  \n          colnames(downloadedData[[dataIndex]]) = NULL;          \n          names(downloadedData)[dataIndex] = paste(SpecificName, \"__NCBI36\", sep = \"\");\n        }\n        if (RefGId == 2)\n        {\n          filename = paste(saveFolderName, \"/\", outputFileName, SpecificName, \"__GRCh37__\", substr(traverseResultFile, ID+1, nchar(traverseResultFile)-4), \".txt\", sep = \"\");\n          write.table(rbind(c(\"Hybridization REF\", exp_names), c(\"miRNA_ID\", column_gene), cbind(gene_left_column, gene_RPM)), file = filename, quote = FALSE, sep = \"\\t\", na = \"\", col.names = FALSE, row.names = FALSE);  \n          \n          # For returning downloaded data\n          dataIndex = dataIndex+1;     \n          downloadedData[[dataIndex]] = rbind(c(\"Hybridization REF\", exp_names), c(\"miRNA_ID\", column_gene), cbind(gene_left_column, gene_RPM));\n          rownames(downloadedData[[dataIndex]]) = NULL;  \n          colnames(downloadedData[[dataIndex]]) = NULL;\n          names(downloadedData)[dataIndex] = paste(SpecificName, \"__GRCh37\", sep = \"\");\n        }\n      }\n      \n    }\n  }\n  \n  writeLines(\"\");\n  writeLines(\"**********************************************************************************\");\n  writeLines(\"\\n\");\n  \n  options(warn=0);\n  \n  downloadedData;\n}\n\n\n\n######################### Auxiliary Functions of Module A #####################################################\n\n# urlReadTable is the function to read a data table from a website and pass it to a variable.\n\n# Input arguments:\n# url: URl of the website from which data table will be obtained.\n\n# Output argument:\n# data: a character matrix holding the data table obtained from website. \n\nurlReadTable <- function(url)\n{\n  \n  data = try(content(GET(url), as = \"text\"), silent = TRUE);\n  if (class(data) == \"try-error\")\n  {\n    return(list(data = data, errorFlag = 1));    \n  }\n  if (length(grep(pattern = \"HTTP 404: Page Not Found\\n\\nThe page you requested was not found.\", x = data, ignore.case = TRUE)) > 0)\n  {\n    return(list(data = data, errorFlag = 2)); \n  }\n  data = gsub(pattern = \"\\r\", replacement = \"\", x = data);\n  data = as.matrix(read.table(text = data, sep=\"\\t\", fill = TRUE, quote = NULL, check.names = FALSE));\n    \n  return(list(data = data, errorFlag = 0));\n}\n\n\n\n# downloadFile is a function to download content from a website and save it as a local file.\n\n# Input arguments:\n# url: URl of the website whose content to be obtained.\n# saveFileName: path and name of the file to store the web content.\n##########delete downloadFile as we may not need it.\n\n\n\n# grepEnd is a function similar to grep but identifies the strings with pattern at the end of the strings.\ngrepEnd <- function(pattern, x, ignore.case = FALSE)\n{\n  ind = grep(pattern = pattern, x = x, ignore.case = ignore.case);\n  if (ignore.case)\n  {\n    ind = ind[nchar(x[ind]) == sapply(str_locate_all(toupper(x[ind]), pattern = toupper(pattern)), function(y){y[dim(y)[1], 2]})];    \n  }else{\n    ind = ind[nchar(x[ind]) == sapply(str_locate_all(x[ind], pattern = pattern), function(y){y[dim(y)[1], 2]})];    \n  }\n}\n\n\n\n# grepBeginning is a function similar to grep but identifies the strings with pattern at the Beginning of the strings.\ngrepBeginning <- function(pattern, x, ignore.case = FALSE)\n{\n  ind = grep(pattern = pattern, x = x, ignore.case = ignore.case);\n  if (ignore.case)\n  {\n    ind = ind[rep(1, length(ind)) == sapply(str_locate_all(toupper(x[ind]), pattern = toupper(pattern)), function(y)y[1, 1])];    \n  }else{\n    ind = ind[rep(1, length(ind)) == sapply(str_locate_all(x[ind], pattern = pattern), function(y)y[1, 1])];    \n  }\n}\n\n\n\n# This function analyzes a TCGA webpage and identify all files and directories on it. \n# The URLs of files and directories are returned using two character vectors.\n\n# Input arguments:\n# TCGA_link: a string of URL for the TCGA webpage to be analyzed.\n\n# Output arguments:\n# file_url: a character vector, including the URLs of all files on the webpage.\n# dir_url: a character vector, including the URLs of all directories on the webpage.\n\n\n############Delete getTCGA_URL as it is only needed for TraverseAllDirectories to get the general directories. We are using the downloaded file instead.\n\n\n# This function selects the newest file URL from all the input URLs by considering the\n# last folder name tail numbers. The number format is *.*.*\n\nGetNewestURL <- function(AllURL)\n{\n  SeriesNum = matrix(rep(\"\", length(AllURL)*3), length(AllURL), 3);\n  NumLength = rep(0, 3);\n  SN = rep(\"\", length(AllURL));\n  for (i in 1:length(AllURL))\n  {\n    Str = AllURL[i];\n    SepID = str_locate_all(string = Str, pattern = \"/\")[[1]];\n    SepID = SepID[(dim(SepID)[1]-1):dim(SepID)[1], 1];\n    Str = substr(Str, SepID[1]+1, SepID[2]-1);\n    Str = strsplit(Str, split = \"\\\\.\")[[1]];\n    SeriesNum[i, ] = Str[(length(Str)-2) : length(Str)];\n    NumLength[1] = max(NumLength[1], nchar(SeriesNum[i, 1]));\n    NumLength[2] = max(NumLength[2], nchar(SeriesNum[i, 2]));\n    NumLength[3] = max(NumLength[3], nchar(SeriesNum[i, 3]));    \n  }\n  \n  for (i in 1:length(AllURL))\n  {\n    for (j in 1:3)\n    {\n      if (nchar(SeriesNum[i, j]) < NumLength[j])\n      {\n        SeriesNum[i, j] = paste(paste(rep(\"0\", NumLength[j] - nchar(SeriesNum[i, j])), collapse = \"\"), SeriesNum[i, j], sep = \"\");\n      }\n    }\n    SN[i] = paste(SeriesNum[i, ], collapse = \"\");\n  }\n  AllURL[which.max(as.numeric(SN))];\n}\n\n\n\n\n#######################################################end TCGAAssembler - ModuleA.R######################################\n#######################################################TCGAAssembler - MOduleB.R########################################\n######################### Main Functions of Module B #############################################################\n\nCombineMultiPlatformData<-function(inputDataList, combineStyle = \"Intersect\")\n{\n  options(warn=-1);\n  \n  for (i in 1:length(inputDataList))\n  {\n    \n    # Keep only one sample for a tissue type of a patient. Usually, there is only one sample of a tissue type of a patient existing in data.\n    inputDataList[[i]]$Data = ToPatientData(inputDataList[[i]]$Data);\n    if (i == 1)\n    {\n      sample = colnames(inputDataList[[i]]$Data);\n    }\n    # For each genomic feature, keep only one row of data.\n    Result = CombineRedundantFeature(Data = inputDataList[[i]]$Data, Des = inputDataList[[i]]$Des);\n    \n    inputDataList[[i]]$Des = Result$Des;\n    inputDataList[[i]]$Data = Result$Data;\n    if (combineStyle == \"Intersect\")\n    {\n      sample = sort(intersect(sample, colnames(inputDataList[[i]]$Data)));\n    }\n    if (combineStyle == \"Union\")\n    {\n      sample = sort(union(sample, colnames(inputDataList[[i]]$Data)));\n    }    \n    if (dim(inputDataList[[i]]$Des)[2] == 1)\n    {\n      inputDataList[[i]]$Des = cbind(inputDataList[[i]]$Des, Description = cbind(rep(\"\", dim(inputDataList[[i]]$Des)[1])));\n    }\n    else\n    {\n      if ((dim(inputDataList[[i]]$Des)[2] == 3) && (inputDataList[[i]]$dataType == \"CNA\"))\n      {\n        inputDataList[[i]]$Des = cbind(inputDataList[[i]]$Des[, 1, drop = FALSE], \n                                       Description = paste(inputDataList[[i]]$Des[, 2], inputDataList[[i]]$Des[, 3], sep = \"\"));\n      }\n    }\n    \n    if (inputDataList[[i]]$dataType == \"miRNAExp\")\n    {\n      for (kk in 1:dim(inputDataList[[i]]$Des)[1])\n      {\n        inputDataList[[i]]$Des[kk, 1] = paste(substr(inputDataList[[i]]$Des[kk, 1], 5, 7), substr(inputDataList[[i]]$Des[kk, 1], 9, 100), sep = \"\");\n      }\n      inputDataList[[i]]$Des[, 1] = toupper(inputDataList[[i]]$Des[, 1]);\n    }\n    \n    # for combining methylation data at CpG site level.\n    if (inputDataList[[i]]$dataType == \"Methylation\")\n    {    \n      if (sum(toupper(c(\"REF\", \"GeneSymbol\", \"ChromosomeID\", \"CoordinateID\")) %in% toupper(colnames(inputDataList[[i]]$Des))) == 4)\n      {\n        inputDataList[[i]]$Des = cbind(inputDataList[[i]]$Des[, \"GeneSymbol\", drop = FALSE], \n                                       Description = paste(inputDataList[[i]]$Des[, \"REF\"], inputDataList[[i]]$Des[, \"ChromosomeID\"], \n                                                           inputDataList[[i]]$Des[, \"CoordinateID\"], sep = \"|\"));\n        inputDataList[[i]]$Des[, \"Description\"] = gsub(\" \", \"\", inputDataList[[i]]$Des[, \"Description\"]);\n      }\n    }\n    \n    inputDataList[[i]]$Des = switch(inputDataList[[i]]$dataType,\n                                    GeneExp = cbind(inputDataList[[i]]$Des[, \"GeneSymbol\", drop = FALSE], \n                                                    Platform = rep(\"GE\", dim(inputDataList[[i]]$Des)[1]), Description = inputDataList[[i]]$Des[, 2]),\n                                    ProteinExp = cbind(inputDataList[[i]]$Des[, \"GeneSymbol\", drop = FALSE], \n                                                       Platform = rep(\"PE\", dim(inputDataList[[i]]$Des)[1]), Description = inputDataList[[i]]$Des[, 2]),                                    \n                                    Methylation = cbind(inputDataList[[i]]$Des[, \"GeneSymbol\", drop = FALSE], \n                                                        Platform = rep(\"ME\", dim(inputDataList[[i]]$Des)[1]), Description = inputDataList[[i]]$Des[, 2]),                                    \n                                    CNA = cbind(inputDataList[[i]]$Des[, \"GeneSymbol\", drop = FALSE], \n                                                Platform = rep(\"CN\", dim(inputDataList[[i]]$Des)[1]), Description = inputDataList[[i]]$Des[, 2]), \n                                    miRNAExp = cbind(inputDataList[[i]]$Des[, \"GeneSymbol\", drop = FALSE],\n                                                     Platform = rep(\"miRExp\", dim(inputDataList[[i]]$Des)[1]), Description = inputDataList[[i]]$Des[, 2]));\n    \n    # check NA gene. which(inputDataList[[i]]$Des[, \"GeneSymbol\"] != \"NA\")\n    ID = intersect(which(!is.na(inputDataList[[i]]$Des[, \"GeneSymbol\"])), \n                   which(inputDataList[[i]]$Des[, \"GeneSymbol\"] != \"?\"));\n    inputDataList[[i]]$Des = inputDataList[[i]]$Des[ID, , drop = FALSE];\n    inputDataList[[i]]$Data = inputDataList[[i]]$Data[ID, , drop = FALSE];    \n    \n  }\n  \n  for (i in 1:length(inputDataList))\n  {\n    # Get the data of samples that should be kept\n    if (combineStyle == \"Intersect\")\n    {\n      inputDataList[[i]]$Data = inputDataList[[i]]$Data[, sample, drop = FALSE];  \n    }\n    if (combineStyle == \"Union\")\n    {\n      tempData = matrix(NA, dim(inputDataList[[i]]$Data)[1], length(sample));\n      colnames(tempData) = sample;\n      tempData[, colnames(inputDataList[[i]]$Data)] = inputDataList[[i]]$Data;\n      inputDataList[[i]]$Data = tempData;  \n    }\n    rownames(inputDataList[[i]]$Data) = NULL;\n    rownames(inputDataList[[i]]$Des) = NULL;  \n  }\n  \n  # Combine the datasets into matrix format\n  Data = inputDataList[[1]]$Data;\n  Des = inputDataList[[1]]$Des;  \n  for (i in 2:length(inputDataList))\n  {\n    Data = rbind(Data, inputDataList[[i]]$Data);\n    Des = rbind(Des, inputDataList[[i]]$Des);    \n  } \n  \n  OrderID = order(as.character(Des[, \"GeneSymbol\"]), as.character(Des[, \"Platform\"]), \n                  as.character(Des[, \"Description\"]), na.last = TRUE, decreasing = FALSE);\n  Data = Data[OrderID, , drop = FALSE];\n  Des = Des[OrderID, , drop = FALSE];\n  rownames(Data) = NULL;\n  rownames(Des) = NULL;\n  Result = list(Des = Des, Data = Data);\n  \n  options(warn=0);\n  \n  Result;\n}\n\n##########delete ExtractTissueSpecificSamples\n\n\nProcessRNASeqData<-function(inputFilePath, outputFileName, outputFileFolder, dataType, verType)\n{\n  options(warn=-1);\n  \n  dir.create(path = outputFileFolder, recursive = TRUE);\n  \n  # Read in data.\n  InData = read.table(file = inputFilePath, header = TRUE, sep = \"\\t\", na.strings = \"\", stringsAsFactors = FALSE, quote = \"\", check.names = FALSE);\n  InData = InData[2:dim(InData)[1], , drop = FALSE];  \n  if ((dataType == \"GeneExp\") & (verType == \"RNASeqV1\"))\n  {\n    REF = InData[, 1];\n    RPKM = as.matrix(InData[, seq(4, dim(InData)[2], 3), drop = FALSE]);\n    mode(RPKM) = \"numeric\";\n    GeneSymbol = sapply(strsplit(REF, split = \"\\\\|\"), function(x)x[1]);\n    EntrezID = sapply(strsplit(REF, split = \"\\\\|\"), function(x)x[2]);\n    Des = cbind(GeneSymbol = GeneSymbol, EntrezID = EntrezID);\n    Data = RPKM;\n    #Check and Correct gene symbol\n    Des = CheckGeneSymbol(Des);    \n  }\n  if (dataType == \"ExonExp\")\n  {\n    REF = InData[, 1];\n    RPKM = as.matrix(InData[, seq(4, dim(InData)[2], 3), drop = FALSE]);\n    mode(RPKM) = \"numeric\";\n    Des = cbind(ExonID = REF);\n    Data = RPKM;    \n  }\n  if ((dataType == \"GeneExp\") & (verType == \"RNASeqV2\"))\n  {\n    REF = InData[, 1];\n    NormalizedCount = as.matrix(InData[, 2:dim(InData)[2], drop = FALSE]);\n    mode(NormalizedCount) = \"numeric\";\n    GeneSymbol = sapply(strsplit(REF, split = \"\\\\|\"), function(x)x[1]);\n    EntrezID = sapply(strsplit(REF, split = \"\\\\|\"), function(x)x[2]);\n    Des = cbind(GeneSymbol = GeneSymbol, EntrezID = EntrezID);\n    Data = NormalizedCount;    \n    #Check and Correct gene symbol\n    Des = CheckGeneSymbol(Des);     \n  }\n  if (verType == \"Microarray\")\n  {\n    dataType = \"GeneExp\";\n    REF = InData[, 1];\n    Data = as.matrix(InData[, 2:dim(InData)[2], drop = FALSE]);\n    mode(Data) = \"numeric\";\n    Des = cbind(GeneSymbol = REF, EntrezID = rep(\"\", length(REF)));\n    #Check and Correct gene symbol\n    Des = CheckGeneSymbol(Des);     \n  }\n  \n  if (dataType == \"GeneExp\")\n  {\n    # Draw and save a box plot\n    png(filename = paste(outputFileFolder, \"/\", outputFileName, \"__boxplot.png\", sep = \"\"), width = 30*dim(Data)[2]+300, height = 1500, units = \"px\");\n    par(las = 2, mai = c(4.5, 1, 0.5, 1), cex = 1.5);\n    nonNaID = which(!is.na(Data));\n    if ((sum(Data[nonNaID]<0)==0) && (max(Data[nonNaID])>50))\n    {\n      boxplot(log2(Data), main = \"Boxplot drawn based on log2 tranformed data.\");\n    } else {\n      boxplot(Data);\n    }\n    dev.off(); \n  }\n  \n  # save data files\n  rownames(Data) = NULL;\n  rownames(Des) = NULL;\n  save(Des, Data, file = paste(outputFileFolder, \"/\", outputFileName, \".rda\", sep = \"\"));\n  write.table(cbind(Des, Data), file = paste(outputFileFolder, \"/\", outputFileName, \".txt\", sep = \"\"), quote = FALSE, \n              sep = \"\\t\", na = \"\", col.names = TRUE, row.names = FALSE); \n  \n  options(warn=0);\n  \n  return(list(Data = Data, Des = Des)); \n}\n\n\n\nProcessmiRNASeqData<-function(inputFilePath, outputFileName, outputFileFolder, fileSource = \"TCGA-Assembler\")\n{\n  options(warn=-1);\n  \n  dir.create(path = outputFileFolder, recursive = TRUE);\n  \n  # Read in data.\n  InData = read.table(file = inputFilePath, header = TRUE, sep = \"\\t\", na.strings = \"\", quote = \"\", stringsAsFactors = FALSE, check.names = FALSE);\n  InData = InData[2:dim(InData)[1], , drop = FALSE];\n  \n  # divide read cout data and RPM data\n  REF = InData[, 1];  \n  if (fileSource == \"Firehose\")\n  {\n    Count = as.matrix(InData[, seq(2, dim(InData)[2], 3), drop = FALSE]);\n    RPM = as.matrix(InData[, seq(3, dim(InData)[2], 3), drop = FALSE]);\n  }\n  if (fileSource == \"TCGA-Assembler\")\n  {\n    Count = as.matrix(InData[, seq(2, dim(InData)[2], 2), drop = FALSE]);\n    RPM = as.matrix(InData[, seq(3, dim(InData)[2], 2), drop = FALSE]);    \n  }\n  #  rownames(Count) = REF;  \n  mode(Count) = \"numeric\";\n  #  rownames(RPM) = REF;\n  mode(RPM) = \"numeric\";\n  \n  #   #   Draw and save box plot\n  #   png(filename = paste(outputFileFolder, \"/\", outputFileName, \"__ReadCount.boxplot.png\", sep = \"\"), width = 30*dim(Count)[2]+300, height = 1500, units = \"px\");\n  #   par(las = 2, mai = c(4.5, 1, 0.5, 1), cex = 1.5);\n  #   boxplot(log2(Count));\n  #   dev.off();\n  #   png(filename = paste(outputFileFolder, \"/\", outputFileName, \"__RPM.boxplot.png\", sep = \"\"), width = 30*dim(RPM)[2]+300, height = 1500, units = \"px\");\n  #   par(las = 2, mai = c(4.5, 1, 0.5, 1), cex = 1.5);\n  #   boxplot(log2(RPM));\n  #   dev.off();  \n  \n  #save data files\n  Des = cbind(GeneSymbol = REF);\n  Data = Count;\n  rownames(Data) = NULL;\n  rownames(Des) = NULL;\n  save(Des, Data, file = paste(outputFileFolder, \"/\", outputFileName, \"__ReadCount.rda\", sep = \"\"));\n  write.table(cbind(Des, Data), file = paste(outputFileFolder, \"/\", outputFileName, \"__ReadCount.txt\", sep = \"\"), quote = FALSE, \n              sep = \"\\t\", na = \"\", col.names = TRUE, row.names = FALSE); \n  Data = RPM; \n  rownames(Data) = NULL;\n  save(Des, Data, file = paste(outputFileFolder, \"/\", outputFileName, \"__RPM.rda\", sep = \"\"));\n  write.table(cbind(Des, Data), file = paste(outputFileFolder, \"/\", outputFileName, \"__RPM.txt\", sep = \"\"), quote = FALSE, \n              sep = \"\\t\", na = \"\", col.names = TRUE, row.names = FALSE); \n  \n  options(warn=0);\n  \n  return(list(Data = Data, Des = Des)); \n}\n\n\n\nCheckGeneSymbol<-function(Des)\n{\n  data(\"hgnc.table\", package=\"HGNChelper\", envir=environment());\n  hgnc.table = rbind(hgnc.table, c(\"13-SEP\", \"SEPT7P2\"));\n  rID = intersect(which(toupper(hgnc.table[, \"Symbol\"]) == toupper(\"NCRNA00185\")), \n                  which(toupper(hgnc.table[, \"Approved.Symbol\"]) == toupper(\"TTTY14\")));\n  hgnc.table = hgnc.table[sort(setdiff(1:dim(hgnc.table)[1], rID)), , drop = FALSE];\n  hgnc.table = hgnc.table[which(!is.na(hgnc.table[, \"Approved.Symbol\"])), , drop = FALSE];\n  regex = \"[0-9]\\\\-(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)|[0-9]\\\\.[0-9][0-9]E\\\\+[[0-9][0-9]\";\n  MonthID = grep(pattern = regex, hgnc.table[, 1], ignore.case = TRUE);\n  MonthMappingTable = hgnc.table[MonthID, , drop = FALSE];\n  Des[, \"GeneSymbol\"] = sub(\"(.*C[0-9XY]+)ORF(.+)\", \"\\\\1orf\\\\2\", Des[, \"GeneSymbol\"]);\n  ID = intersect(which(!Des[, \"GeneSymbol\"] %in% hgnc.table[, \"Approved.Symbol\"]), which(Des[, \"GeneSymbol\"] %in% hgnc.table[, \"Symbol\"]));\n  DesOrg = Des;\n  if (length(ID) > 0)\n  {\n    Des[ID, \"GeneSymbol\"] = sapply(Des[ID, \"GeneSymbol\"], function(x)paste(hgnc.table[hgnc.table[, \"Symbol\"] == x, \"Approved.Symbol\"], collapse = \"___\"));\n  }\n  #  writeLines(\"Changed genes are\");\n  #  print(cbind(DesOrg[ID, \"GeneSymbol\"], Des[ID, \"GeneSymbol\"]));  \n  ID = intersect(which(!Des[, \"GeneSymbol\"] %in% hgnc.table[, \"Approved.Symbol\"]), which(toupper(Des[, \"GeneSymbol\"]) %in% toupper(MonthMappingTable[, \"Symbol\"])));\n  if (length(ID) > 0)\n  {\n    Des[ID, \"GeneSymbol\"] = sapply(Des[ID, \"GeneSymbol\"], function(x)paste(MonthMappingTable[toupper(MonthMappingTable[, \"Symbol\"]) == toupper(x), \"Approved.Symbol\"], collapse = \"___\"));\n  }\n  #  writeLines(\"Changed genes are\");\n  #  print(cbind(DesOrg[ID, \"GeneSymbol\"], Des[ID, \"GeneSymbol\"]));  \n  Des;\n}\n\n#delete ProcessRPPADataWithGeneAnnotation\n\n######################### Auxiliary Functions of Module B #############################################################\n\nToPatientData<-function(TCGAData)\n{\n  TCGABarcode = colnames(TCGAData);\n  TCGABarcode = sapply(strsplit(TCGABarcode, split = \"-\"), function(x){\n    Str = paste(x[1], x[2], x[3], substr(x[4], 1, 2), sep = \"-\");\n    Str;\n  });\n  DuplicatedLabel = duplicated(TCGABarcode);\n  ID = which(DuplicatedLabel == FALSE);\n  TCGAData = TCGAData[, ID, drop = FALSE];\n  TCGABarcode = TCGABarcode[ID];\n  colnames(TCGAData) = TCGABarcode;\n  TCGAData;\n}\n\n\n\nCombineRedundantFeature <- function(Data, Des)\n{\n  RowName = Des[, 1];\n  if (dim(Des)[2] > 1)\n  {\n    for (i in 2:dim(Des)[2])\n    {\n      RowName = paste(RowName, Des[, i], sep = \"||\");\n    }\n  }\n  \n  UniqueRowName = unique(RowName);\n  if (length(RowName) == length(UniqueRowName))\n  {\n    Result = list(Data = Data, Des = Des);\n  }\n  else\n  {\n    IDKeep = c();\n    for (i in 1:length(UniqueRowName))\n    {\n      IDi = which(RowName == UniqueRowName[i]);\n      if (length(IDi) > 1)\n      {\n        Data[IDi[1], ] = apply(Data[IDi, , drop = FALSE], 2, mean, na.rm = TRUE);\n      }\n      IDKeep = c(IDKeep, IDi[1]);\n    }\n    IDKeep = sort(IDKeep);\n    Result = list(Data = Data[IDKeep, , drop = FALSE], Des = Des[IDKeep, , drop = FALSE]);\n  }\n  Result;\n}\n\n\n###delete normalize.quantiles\n\n\n#####################\n############Delete VCwebContent\n\n\n#######################################################end TCGAAssembler ModulB.R###########################\n\n\n\n\n#' Get data from TCGA\n#' \n#' Download matched miRNA and mRNA expression profiles from TCGA using TCGA Assembler. In order to this function to work, users need to download the\n#' the file \"DirectoryTraverseResult_Jul-08-2014.rda\" from nugget.unisa.edu.au/Thuc/miRLAB/ and place it in the working directory \n\n#' @param CancerName The name of cancer using abbreviation of cancer name as one of the followings:\n#' \\itemize{\n#' \\item Adrenocortical carcinoma: ACC\n#' \\item Bladder urothelial carcinoma: BLCA\n#' \\item Breast invasive carcinoma: BRCA\n#' \\item Cervical squamous cell carcinoma and endocervical adenocarcinoma: CESC\n#' \\item Colon adenocarcinoma: COAD\n#' \\item Lymphoid neoplasm diffuse large B-cell lymphoma: DLBC\n#' \\item Esophageal carcinoma: ESCA\n#' \\item Glioblastoma multiforme: GBM\n#' \\item Head and neck squamous cell carcinoma: HNSC\n#' \\item Kidney chromophobe: KICH\n#' \\item Kidney renal clear cell carcinoma: KIRC\n#' \\item Kidney renal papillary cell carcinoma: KIRP\n#' \\item Acute myeloid leukemia: LAML\n#' \\item Brain lower grade glioma: LGG\n#' \\item Liver hepatocellular carcinoma: LIHC\n#' \\item Lung adenocarcinoma: LUAD\n#' \\item Lung squamous cell carcinoma: LUSC\n#' \\item Ovarian serous cystadenocarcinoma: OV\n#' \\item Pancreatic adenocarcinoma: PAAD\n#' \\item Prostate adenocarcinoma: PRAD\n#' \\item Rectum adenocarcinoma: READ\n#' \\item Sarcoma: SARC\n#' \\item Skin cutaneous melanoma: SKCM\n#' \\item Stomach adenocarcinoma: STAD\n#' \\item Thyroid carcinoma: THCA\n#' \\item Uterine corpus endometrial carcinoma: UCEC\n#' \\item Uterine carcinosarcoma: UCS\n#' }\n#' @return Dataset of matched miRNA and mRNA expression profiles \n#' @examples \n#' \\dontrun{\n#' BreastCancer=getData(\"BRCA\") \n#' }\n#' @references \n#' Zhu, Y., Qiu, P., and Ji, Y. (2014). TCGA-Assembler: open-source software for retrieving and processing TCGA data. Nat. Methods, 11, 599-600.\n#' @export\ngetData<-function(CancerName){\n#rm(list = ls()); # Clear workspace\n#source(\"Module_A.r\"); # Load Module A functions\n#source(\"Module_B.r\"); # Load Module B functions\n\n# Get the URLs of public data files of all cancer types and all assay platforms.\n# TraverseAllDirectories(entryPoint = \"https://tcga-data.nci.nih.gov/tcgafiles/ftp_auth/distro_ftpusers/anonymous/tumor/\", fileLabel = \"DirectoryTraverseResult\");\n\n# Download and process miRNA-seq data of all CancerName patient samples.\nmiRNASeqRawData = DownloadmiRNASeqData(traverseResultFile = \"./DirectoryTraverseResult_Jul-08-2014.rda\", saveFolderName = \"./UserData/RawData.TCGA-Assembler\", cancerType = CancerName, assayPlatform = \"miRNASeq\");\nmiRNADataName=substr(colnames(data.frame(miRNASeqRawData[1]))[1],1,nchar(colnames(data.frame(miRNASeqRawData[1]))[1])-2);\nInputmiRNAfilename = paste(\"./UserData/RawData.TCGA-Assembler/\",miRNADataName,\"__Jul-08-2014\",\".txt\",sep=\"\");\nOutputmiRNAfilename = paste(CancerName,\"_illuminahiseq_mirnaseq\",sep=\"\");\nmiRNASeqData = ProcessmiRNASeqData(inputFilePath = InputmiRNAfilename, outputFileName = OutputmiRNAfilename, outputFileFolder = \"./UserData/ProcessedData.TCGA-Assembler\");\n\n# Download and process normalized gene expression data of all CancerName patient samples\nRNASeqRawData = DownloadRNASeqData(traverseResultFile = \"./DirectoryTraverseResult_Jul-08-2014.rda\", saveFolderName = \"./UserData/RawData.TCGA-Assembler\", cancerType = CancerName, assayPlatform = \"RNASeqV2\", dataType = \"rsem.genes.normalized_results\");\nRNADataName=substr(colnames(data.frame(RNASeqRawData[1]))[1],1,nchar(colnames(data.frame(RNASeqRawData[1]))[1])-2);\nInputRNAfilename = paste(\"./UserData/RawData.TCGA-Assembler/\",RNADataName,\"__Jul-08-2014\",\".txt\",sep=\"\");\nOutputRNAfilename = paste(CancerName,\"_illuminahiseq_rnaseqv2__GeneExp\",sep=\"\");\nGeneExpData = ProcessRNASeqData(inputFilePath = InputRNAfilename, outputFileName = OutputRNAfilename, outputFileFolder = \"./UserData/ProcessedData.TCGA-Assembler\", dataType = \"GeneExp\", verType = \"RNASeqV2\");\n\n# Put multi-modal data in a vector of list objects to be inputted into CombineMultiPlatformData function.\ninputDataList = vector(\"list\", 2);\ninputDataList[[1]] = list(Des = miRNASeqData$Des, Data = miRNASeqData$Data, dataType = \"miRNAExp\");\ninputDataList[[2]] = list(Des = GeneExpData$Des, Data = GeneExpData$Data, dataType = \"GeneExp\");\n\n# Merge multi-platform data using Intersect approach.\nMergedData = CombineMultiPlatformData(inputDataList = inputDataList);\n# Merge multi-platform data using Union approach.\n# MergedData = CombineMultiPlatformData(inputDataList = inputDataList, combineStyle = \"Union\");\n   \nreturn(MergedData)\n\n}\n\n#' Read dataset from csv file\n#' @param dataset The input dataset in csv format\n#' @return dataset in matrix format\n#' @examples\n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' data=Read(dataset)\n#' @export\nRead<-function(dataset){\n\t\tdata<-read.csv(dataset, header=TRUE, sep=\",\")\n\t\treturn(data)\n\t}\n\n############ Get data header from dataset ###############\n#' Read the header of the dataset\n#' @return the header of the dataset\n#' @param dataset the character string of the names of the dataset in csv format, e.g. \"ToyEMT.csv\"\n#' @examples\n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' header=readHeader(dataset)\n#' @export\nreadHeader<-function(dataset){\n  data<-read.csv(dataset, header=FALSE)\n  header<-character()\n  for (i in 1:ncol(data)){\n  header[i]=toString(data[1,i])\n  }\n  return(header)\n}\n\n############ Convert target information into a binary matrix, the rows are mRNAs and the columns are miRNAs ###############\nqueryTargetFile<-function(miRNA,mRNA,file){\n  #the column name of file should be tagged as \"mir\" and \"gene\"\n  data<-Read(file)\n  mir=as.character(data$mir)\n  #   mir<-paste(\"hsa-\",sep=\"\",mir);mir<-sub('r','R',mir)\n  gene=as.character(data$gene)\n  #   symbol<-geneSymbol(gene)\n  sum=0\n  rep<-replicate(length(miRNA),mir)\n  edge=matrix(FALSE,length(miRNA)+length(mRNA),length(miRNA)+length(mRNA))\n  for (i in 1:length(mir)){\n    #     print(i)\n    if (length(which(rep[i,]==miRNA)>0)){\n      match1<-which(rep[i,]==miRNA,arr.ind=TRUE)\n      #gene: gene[i] #mirna: miRNA[match]\n      rep2<-replicate(length(mRNA),gene[i])\n      match2<-which(rep2==mRNA,arr.ind=TRUE)\n      edge[match1,match2+length(miRNA)]=TRUE\n    }\n  }\n  return(edge)\n}\n\t\n\t\n#' Stardarsise the dataset\n#' Stadardise the dataset to have mean=0 and std=1 in each column.\n#' @param dataset The input dataset in csv format. e.g. \"ToyEMT.csv\". The first column is the sample name.\n#' @return The standardised dataset.\n#' @examples\n#' \\dontrun{\n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' stdata=Standardise(dataset)\n#' }\n\tStandardise<-function(dataset){\n\t\tncol<-ncol(dataset)\n\t\tnrow<-nrow(dataset)\n\t\tstdData<-matrix(nrow=nrow,ncol=ncol-1)\n              rownames(stdData)<-dataset[,1]\n              colnames<-colnames(dataset)\n              colnames(stdData)<-colnames[2:ncol]\n\t\tfor (i in 2:ncol){\n\t\t\tstdData[,i-1]<-scale(dataset[i],center=TRUE, scale=TRUE)\n\t\t\t}\n\t\treturn(stdData)\n\t}\n\n#' Filter, impute, and normalise data.\n#' \n#' Remove the genes (rows) that have more than r\\% of missing data;\n#' use the impute package to fill in missing data, and finally normalise the data.\n#' @importFrom impute impute.knn\n#' @importFrom limma normalizeBetweenArrays\n#' @param dataset The input dataset in csv format. e.g. \"EMT.csv\" \n#' #' @param r The rate threshold to filter the records (genes). Genes with more than r\\% missing data will be removed.\n#' @return The processed dataset.\n#' @references \n#' 1. Hastie T, Tibshirani R, Narasimhan B and Chu G. impute: Imputation for microarray data. R package version 1.42.0.\n#' \n#' 2. Smyth, G.K. (2005). Limma: linear models for microarray data. In Bioinformatics and computational biology solutions using R and Bioconductor (pp. 397-420). Springer New York.\n#' @examples\n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' impdata=ImputeNormData(dataset, 0.1)\n#' @export\nImputeNormData<-function(dataset, r){\n               #library(impute)\n               Rawdata<-Read(dataset)\n               #Rawnames<-as.matrix(Rawdata)[,1]\n              # Rawdata<-Rawdata[,-1]\n               #rownames(Rawdata)<-Rawnames\n                              \n               #Removing genes which samples having more r% zero counts or missing value\n               Rawdata<-Rawdata[which(rowSums(Rawdata==0)<r*dim(Rawdata)[2]),]\n               data<-Rawdata[which(rowSums(is.na(Rawdata))<r*dim(Rawdata)[2]),]\n             \n               #if(exists(\".Random.seed\")) rm(.Random.seed)\n               imputed<-impute.knn(as.matrix(data) ,k = 10, rowmax = 0.5, colmax = 0.8, maxp = 1500, rng.seed=362436069)\n               dataimputed<-imputed$data\n               \n               #Make log2 transformation for expression data\n               dataimputed<-log2(dataimputed)                    \n                            \n               #normalizeBetweenArrays in limma\n               #library(limma)\n               normlog<-matrix(data = dataimputed, nrow =dim(dataimputed)[1], ncol = dim(dataimputed)[2], byrow = TRUE, dimnames = NULL)\n               normlogbtwarray<-normalizeBetweenArrays(normlog,method='quantile')\n               rownames(normlogbtwarray)=rownames(data)             \n               colnames(normlogbtwarray)=colnames(data)\n\n               return(normlogbtwarray)\n}\n\n#' Differentially expressed analysis\n#' \n#' Find the top miRNAs and mRNAs that are differently expression between different conditions, e.g. cancer vs normal\n#' @importFrom limma lmFit makeContrasts contrasts.fit eBayes topTable\n#' @param miR1 the miRNA dataset for condition 1, e.g. cancer\n#' @param miR2 the miRNA dataset for condition 1, e.g. normal\n#' @param mR1  the mRNA dataset for condition 1, e.g. cancer\n#' @param mR2  the mRNA dataset for condition 2, e.g. normal\n#' @param topkmiR the maximum number of miRNAs that we would like to extract, e.g. top 50 miRNAs.\n#' @param topkmR the maximum number of mRNAs that we would like to extract, e.g. top 2000 mRNAs.\n#' @param p.miR cutoff value for adjusted p-values when conducting differentially expressed analysis for miRNAs.\n#' @param p.mR cutoff value for adjusted p-values when conducting differentially expressed analysis for mRNAs.\n#' @return the dataset that includes differentially expressed miRNAs and mRNAs. columns are miRNAs and mRNAs  and rows are samples\n#' @references\n#' Smyth, G.K. (2005). Limma: linear models for microarray data. In Bioinformatics and computational biology solutions using R and Bioconductor (pp. 397-420). Springer New York.\n#' @export\nDiffExpAnalysis=function(miR1, miR2, mR1, mR2,topkmiR, topkmR, p.miR, p.mR){\n\t#miR1: miRNA dataset in condition 1, rows are miRNAs, samples are columns\n\t#miR2: condition2\n\t#mR1, mR2: genes in 2 conditions.\n\t# topk: the number of genes that we want to extract.\n\t\n\t#library(limma)\n\tmiR1=read.csv(miR1, header=TRUE, sep=\",\")\n\tmiRnames=miR1[,1]\n\tmiR1=miR1[,-1]\n\tc1=ncol(miR1)\n\t\n\tmiR2=read.csv(miR2, header=TRUE, sep=\",\")\n\tmiR2=miR2[,-1]\n\tc2=ncol(miR2)\n\t\n\tmiR=cbind(miR1, miR2)\n\trownames(miR)=miRnames\n\t#miR=t(miR)\n\t\n\tmR1=read.csv(mR1, header=TRUE, sep=\",\")\n\tmRnames=mR1[,1]\n\tmR1=mR1[,-1]\n\tmR2=read.csv(mR2, header=TRUE, sep=\",\")\n\tmR2=mR2[,-1]\n\tmR=cbind(mR1, mR2)\n\trownames(mR)=mRnames\n\t#mR=t(mR)\n\tNormal=NULL\n  Cancer=NULL\n\t########## miR ############\n\tdesign=cbind(Normal=c(rep(1,c1), rep(0,c2)), Cancer=c(rep(0,c1), rep(1,c2)))\n\tmiRfit=lmFit(miR, design)\n\tcontrast.matrix=makeContrasts(NormalvCancer=Normal - Cancer, levels=design)\n\tmiRfit2=contrasts.fit(miRfit, contrast.matrix)\n\tmiRfit2=eBayes(miRfit2)\n\tmiRresults=topTable(miRfit2, number= topkmiR, p.value=p.miR, sort.by=\"p\", adjust.method=\"BH\")\n\twrite.csv(miRresults, file=\"DiffExpmiR.csv\")\n\t########## mR ############\n\tmRfit=lmFit(mR, design)\n\tcontrast.matrix=makeContrasts(NormalvCancer=Normal - Cancer, levels=design)\n\tmRfit2=contrasts.fit(mRfit, contrast.matrix)\n\tmRfit2=eBayes(mRfit2)\n\tmRresults=topTable(mRfit2, number= topkmR, p.value=p.mR, sort.by=\"p\", adjust.method=\"BH\")\n\twrite.csv(mRresults, file=\"DiffExpmR.csv\")\n        miRSymbol=rownames(miRresults)\n        mRSymbol=rownames(mRresults)\n        miRExp=miR[which(miRnames %in% miRSymbol),]\n        mRExp=mR[which(mRnames %in% mRSymbol),]\n        \n        miRExp=t(miRExp)\n        mRExp=t(mRExp)\n        \n        DExp=cbind(miRExp,mRExp)\n        \n        return(DExp)\n        \t\n}\n\t\n#' miRNA target prediction with the Pearson correlation coefficient method\n#' \n#' Calculate the Pearson correlation coefficient of each pair of miRNA-mRNA,and return a matrix of correlation coefficients with columns are miRNAs and rows are mRNAs.\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the Pearson correlation coefficients. Columns are miRNAs, rows are mRNAs.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=Pearson(dataset, 1:3, 4:18) \n#' \n#' @references\n#' Pearson, K. (1920) Notes on the history of correlation. Biometrika, 13, 25 - 45.\n#' @export \n\n## 1. Pearson ##\nPearson=function(datacsv, cause, effect, targetbinding=NA){\ndata=Read(datacsv)\ndata=scale(data) #standardise the data\nheader<-readHeader(datacsv)\nnum_miRNA<-length(cause)\nmiR<-header[1:num_miRNA]\nmR<-header[-(1:num_miRNA)]\n\nmiRNA=data[,cause]\nmRNA=data[,effect]\ncorMat=cor(mRNA, miRNA, method=\"pearson\")# miRNAs in columns and mRNAs in rows\n\nif(is.na(targetbinding)==FALSE){\n#query knowledge matrix from file\nedgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \nedgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\nedgeTargetScan<-edgeTargetScan!=0;\nedge=edgeTargetScan[effect,cause]\ncorMat=corMat*edge\n}\n\nreturn(corMat)\n}\n\n#' miRNA target prediction with the Spearman correlation coefficient method\n#' \n#' Calculate the Spearman correlation coefficient of each pair of miRNA-mRNA,and return a matrix of correlation coefficients with columns are miRNAs and rows are mRNAs.\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the Spearman correlation coefficients. Columns are miRNAs, rows are mRNAs.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=Spearman(dataset, 1:3, 4:18) \n#' \n#' @references\n#' Spearman, C. (1904) General intelligence, objectively determined and measured. Am. J. Psychol., 15, 201 - 92.\n#' @export \n## 2. Spearman ##\nSpearman=function(datacsv, cause, effect, targetbinding=NA){\ndata=Read(datacsv)\ndata=scale(data) #standardise the data\nheader<-readHeader(datacsv)\nnum_miRNA<-length(cause)\nmiR<-header[1:num_miRNA]\nmR<-header[-(1:num_miRNA)]\n\nmiRNA=data[,cause]\nmRNA=data[,effect]\ncorMat=cor(mRNA, miRNA, method=\"spearman\")# miRNAs in columns and mRNAs in rows\n\n\nif(is.na(targetbinding)==FALSE){\n#query knowledge matrix from file\nedgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \nedgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\nedgeTargetScan<-edgeTargetScan!=0;\nedge=edgeTargetScan[effect,cause]\ncorMat=corMat*edge\n}\n\nreturn(corMat)\n}\n\n#' miRNA target prediction with the Kendall correlation coefficient method\n#' \n#' Calculate the Kendall correlation coefficient of each pair of miRNA-mRNA,and return a matrix of correlation coefficients with columns are miRNAs and rows are mRNAs.\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the Kendall correlation coefficients. Columns are miRNAs, rows are mRNAs.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=Kendall(dataset, 1:3, 4:18) \n#' @references\n#' Kendall, M. (1938) A new measure of rank correlation. Biometrika, 30, 81 - 9.\n#' @export \n## 3. Kendall ##\nKendall=function(datacsv, cause, effect, targetbinding=NA){\ndata=Read(datacsv)\ndata=scale(data) #standardise the data\nheader<-readHeader(datacsv)\nnum_miRNA<-length(cause)\nmiR<-header[1:num_miRNA]\nmR<-header[-(1:num_miRNA)]\n\nmiRNA=data[,cause]\nmRNA=data[,effect]\ncorMat=cor(mRNA, miRNA, method=\"kendall\")# miRNAs in columns and mRNAs in rows\n\n\nif(is.na(targetbinding)==FALSE){\n#query knowledge matrix from file\nedgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \nedgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\nedgeTargetScan<-edgeTargetScan!=0;\nedge=edgeTargetScan[effect,cause]\ncorMat=corMat*edge\n}\n\nreturn(corMat)\n}\n\n#' miRNA target prediction with the Distance correlation  method\n#' \n#' Calculate the Distance correlation  of each pair of miRNA-mRNA,and return a matrix of correlation coefficients with columns are miRNAs and rows are mRNAs.\n#' @importFrom energy dcov\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the Distance correlation values. Columns are miRNAs, rows are mRNAs.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=Dcov(dataset, 1:3, 4:18) \n#' @references\n#' Szekely, G., Rizzo, M. and Bakirov, N. (2007) Measuring and testing independence by correlation of distances. Ann. Stat., 35, 2769 - 94.\n#' @export \n## 4. Dcov(Distance correlation) ##\nDcov <- function(datacsv, cause, effect, targetbinding=NA) {\n\n       # library(energy)\n        data=Read(datacsv)\n        data=scale(data)\n        header<-readHeader(datacsv)\n        num_miRNA<-length(cause)\n        miR<-header[1:num_miRNA]\n        mR<-header[-(1:num_miRNA)]\n\n        allnames=colnames(data)\n\tcausenames=allnames[cause]\n\teffectnames=allnames[effect]\n\tResult<-matrix(nrow=length(effect), ncol=length(cause))\n        for (i in cause){\n                     for (j in effect){\n                        Result[j-length(cause),i]<-dcov(data[,i],data[,j]) # Calculate Distance correlation.\n                      }\n         }\n       colnames(Result)=causenames\n       rownames(Result)=effectnames\n       \n       \nif(is.na(targetbinding)==FALSE){\n#query knowledge matrix from file\nedgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \nedgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\nedgeTargetScan<-edgeTargetScan!=0;\nedge=edgeTargetScan[effect,cause]\nResult=Result*edge\n}\n \nreturn(Result)\n}\n#' miRNA target prediction with the Hoeffding correlation coefficient method\n#' \n#' Calculate the Hoeffding correlation coefficient of each pair of miRNA-mRNA,and return a matrix of correlation coefficients with columns are miRNAs and rows are mRNAs.\n#' @importFrom Hmisc hoeffd \n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the Hoeffding correlation coefficients. Columns are miRNAs, rows are mRNAs.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=Hoeffding(dataset, 1:3, 4:18) \n#' @references\n#' Hoeffding, W. (1948) A non-parametric test of independence. Ann. Math. Stat., 19, 546 - 57.\n#' @export \n## 5. Hoeffding(Hoeffding's D measure) ##\nHoeffding <- function(datacsv, cause, effect, targetbinding=NA) {\n\n       #library(Hmisc)\n        data=Read(datacsv)\n        data=scale(data)\n        header<-readHeader(datacsv)\n        num_miRNA<-length(cause)\n        miR<-header[1:num_miRNA]\n        mR<-header[-(1:num_miRNA)]        \n\n        allnames=colnames(data)\n\tcausenames=allnames[cause]\n\teffectnames=allnames[effect]\n\tResult<-matrix(nrow=length(effect), ncol=length(cause))\n        for (i in cause){\n                     for (j in effect){\n                        Result[j-length(cause),i]<-as.numeric(c(hoeffd(data[,i],data[,j])[\"D\"], recursive = TRUE)[2]) # Calculate Hoeffding's D measure.\n                      }\n         }\n       colnames(Result)=causenames\n       rownames(Result)=effectnames\n\nif(is.na(targetbinding)==FALSE){\n#query knowledge matrix from file\nedgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \nedgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\nedgeTargetScan<-edgeTargetScan!=0;\nedge=edgeTargetScan[effect,cause]\nResult=Result*edge\n}\n\nreturn(Result)\n}\n\n\n\n#' @importFrom entropy mi.empirical\n#' @importFrom gplots hist2d\n      \nEMI <- function(x, y) {\n   # library(ghyp)\n   # library(entropy)\n    Mx <- matrix(x, length(x), 1)\n    My <- matrix(y, length(y), 1)\n    nbins <- ceiling(log(length(Mx[,1]),2)) + 1\n    a <- hist2d(cbind(Mx,My), nbins=nbins,show=FALSE)\n    result <- mi.empirical(a$counts)\n    return(result)\n}\n\n#' miRNA target prediction with  mutual information method\n#' \n#' Calculate the mutual information of each pair of miRNA-mRNA,and return a matrix of mutual information values with columns are miRNAs and rows are mRNAs.\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the mutual information values. Columns are miRNAs, rows are mRNAs.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=MI(dataset, 1:3, 4:18) \n#' @references\n#' Moon, Y.I., Balaji, R., and Lall, U. (1995) Estimation of mutual information using kernel density estimators. Phys. Rev. E, 52, 2318 - 21.\n#' @export \n\nMI <- function(datacsv, cause, effect, targetbinding=NA) {\n        data=Read(datacsv)\n        data=scale(data)\n        header<-readHeader(datacsv)\n        num_miRNA<-length(cause)\n        miR<-header[1:num_miRNA]\n        mR<-header[-(1:num_miRNA)]\n\n        allnames=colnames(data)\n\tcausenames=allnames[cause]\n\teffectnames=allnames[effect]\n\tResult<-matrix(nrow=length(effect), ncol=length(cause))\n        for (i in cause){\n                     for (j in effect){\n                        Result[j-length(cause),i]<-EMI(data[,i],data[,j]) # Calculate Mutual Information.\n                      }\n         }\n       colnames(Result)=causenames\n       rownames(Result)=effectnames       \n\nif(is.na(targetbinding)==FALSE){\n#query knowledge matrix from file\nedgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \nedgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\nedgeTargetScan<-edgeTargetScan!=0;\nedge=edgeTargetScan[effect,cause]\nResult=Result*edge\n}\n\nreturn(Result)\n}\n\n#' miRNA target prediction with the IDA method\n#' \n#' Calculate the causal effect of each pair of miRNA-mRNA,and return a matrix of causal effects with columns are miRNAs and rows are mRNAs.\n#' @importFrom pcalg pc idaFast gaussCItest\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param pcmethod choose different versons of the PC algorithm, including \"original\" (default)\n#' \"stable\", and \"stable.fast\"\n#' @param alpha significance level for the conditional independence test, e.g. 0.05.\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the causal effects. Columns are miRNAs, rows are mRNAs.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=IDA(dataset, 1:3, 4:18) \n#' @references\n#' 1. Le, T.D., Liu, L., Tsykin, A., Goodall, G.J., Liu, B., Sun, B.Y. and Li, J. (2013) Inferring microRNA-mRNA causal regulatory relationships from expression data. Bioinformatics, 29, 765-71.\n#' \n#' 2. Zhang, J., Le, T.D., Liu, L., Liu, B., He, J., Goodall, G.J. and Li, J. (2014) Identifying direct miRNA-mRNA causal regulatory relationships in heterogeneous data. J. Biomed. Inform., 52, 438-47.\n#' \n#' 3. Maathuis, H.M., Colombo, D., Kalisch, M. and Buhlmann, P. (2010) Predicting causal effects in large-scale systems from observational data. Nat. Methods, 7, 247-249.\n#' \n#' 4. Maathuis, H.M., Kalisch, M. and Buhlmann, P. (2009) Estimating high-dimensional intervention effects from observational data. Ann. Stat., 37, 3133-3164.\n#' @export \n## 7. IDA ##\nIDA=function(datacsv, cause, effect, pcmethod=\"original\", alpha=0.05, targetbinding=NA){\n     #   library(pcalg)\n\n\tif(is.character(datacsv)){\n\t\tdata=Read(datacsv)\n\t\t#data=data[,-1] # if the dataset have the sample names column, otherwise comment this out.\n\t} else {\n\t\tdata=datacsv #Assume there is no samplenames column and this is a data.frame.\n\t}\t\t\t\t\t\t\t\n\tdata=scale(data) #standardise the data\n\theader<-readHeader(datacsv)\n        num_miRNA<-length(cause)\n        miR<-header[1:num_miRNA]\n        mR<-header[-(1:num_miRNA)]\n\n        #print(data[1:5,])\n\tallnames=colnames(data)\n\tcausenames=allnames[cause]\n\teffectnames=allnames[effect]\n\t\t\n\tmultiset=character(0)\n\tresult=matrix(nrow=length(effect), ncol=length(cause))\n\tsuffStat=list(C=cor(data), n=nrow(data))\n\tindepTest=gaussCItest\n\t\n\tpcFit <- pc(suffStat, indepTest, p=ncol(data), alpha=alpha, skel.method=pcmethod)\n\tfor (l in cause){\n\t\t\t\t\n\t\t\t#Inferring causal effects\n\t\t\tcaef<-idaFast(l,effect,cov(data), pcFit@graph )\n\t\t\n\t\t\t#min of absolute values.\n\t\t\tcaef1<-matrix(nrow=length(effect),ncol=1)\n\t\t\tfor (k in 1:length(effect)){\n\t\t\t\tcaefabs<-abs(caef)\n\t\t\t\tindex<-which(caefabs==min(caefabs[k,]), arr.ind=TRUE)\n\t\t\t\tpos<-index[1,2]\n\t\t\t\tcaef1[k,]<-caef[k,pos]\n\t\t\t}\n\t\t\tresult[,l]<-caef1\n\t}\n\tcolnames(result)=causenames\n\trownames(result)=effectnames\n\nif(is.na(targetbinding)==FALSE){\n#query knowledge matrix from file\nedgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \nedgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\nedgeTargetScan<-edgeTargetScan!=0;\nedge=edgeTargetScan[effect,cause]\nresult=result*edge\n}\n\nreturn(result)\t\n}\n\n\n\n## 9. RDC(Randomized Dependence Coefficient) ##\nRDCParameter <- function(x,y,k=20,s=1/6,f=sin) {\n  x <- cbind(apply(as.matrix(x),2,function(u)rank(u)/length(u)),1)\n  y <- cbind(apply(as.matrix(y),2,function(u)rank(u)/length(u)),1)\n  x <- s/ncol(x)*x%*%matrix(rnorm(ncol(x)*k),ncol(x))\n  y <- s/ncol(y)*y%*%matrix(rnorm(ncol(y)*k),ncol(y))\n  cancor(cbind(f(x),1),cbind(f(y),1))$cor[1]\n}\n\n#' miRNA target prediction with the Randomized Dependence Coefficient method\n#' \n#' Calculate the Randomized Dependence coefficient of each pair of miRNA-mRNA,and return a matrix of  coefficients with columns are miRNAs and rows are mRNAs.\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the  correlation coefficients. Columns are miRNAs, rows are mRNAs.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=RDC(dataset, 1:3, 4:18) \n#' @export \n\nRDC <- function(datacsv,cause, effect, targetbinding=NA) {\n        data=Read(datacsv)\n        data=scale(data) #standardise the data\n        header<-readHeader(datacsv)\n        num_miRNA<-length(cause)\n        miR<-header[1:num_miRNA]\n        mR<-header[-(1:num_miRNA)]\n\n        allnames=colnames(data)\n\tcausenames=allnames[cause]\n\teffectnames=allnames[effect]\n        \n\tResult<-matrix(nrow=length(effect), ncol=length(cause))\n        for (i in cause){\n                     for (j in effect){\n                        Result[j-length(cause),i]<-RDCParameter(data[,i],data[,j],k=20,s=1/6,f=sin) # Calculate Randomized Dependence Coefficient.\n                      }\n         }\n\n        colnames(Result)=causenames\n\trownames(Result)=effectnames\n\nif(is.na(targetbinding)==FALSE){\n#query knowledge matrix from file\nedgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \nedgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\nedgeTargetScan<-edgeTargetScan!=0;\nedge=edgeTargetScan[effect,cause]\nResult=Result*edge\n}\n        \nreturn(Result)\n}\n#' miRNA target prediction with the Lasso method\n#' \n#' Calculate the Lasso regression coefficient of each pair of miRNA-mRNA, and return a matrix of coefficients with columns are miRNAs and rows are mRNAs.\n#' @importFrom glmnet glmnet\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the Lasso regression coefficients. Columns are miRNAs, rows are mRNAs.\n#' @examples\n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=Lasso(dataset, 1:3, 4:18) \n#' @references\n#' 1. Le, T.D., Zhang, J., Liu, L., and Li, J. (2015) Ensemble Methods for miRNA Target Prediction from Expression Data, submitted.\n#' \n#' 2. Tibshirani, R. (1996). Regression shrinkage and selection via the lasso. J. R. Stat. Soc. Series B Stat. Methodol., 267-288.\n#' @export \n## 10. Lasso ##\nLasso=function(datacsv, cause, effect, targetbinding=NA){\n # library(glmnet)\n\tif(is.character(datacsv)){\n\t\tdata=Read(datacsv)\n\t\t#data=data[,-1] # if the dataset have the sample names column, otherwise comment this out.\n\t} else {\n\t\tdata=datacsv #Assume there is no samplenames column and this is a data.frame.\n\t}\t\t\t\t\t\t\t#To allow both .csv data input or a matrix in R. This will help the IDAbootstrap, as IDA can run on sampling matrices.\n\tdata=scale(data) #standardise the data\n        header<-readHeader(datacsv)\n        num_miRNA<-length(cause)\n        miR<-header[1:num_miRNA]\n        mR<-header[-(1:num_miRNA)]\n  data=as.matrix(data)\n\t#print(data[1:5,])\n\tallnames=colnames(data)\n\tcausenames=allnames[cause]\n\teffectnames=allnames[effect]\n\tres=matrix(nrow=length(effectnames), ncol=length(causenames), 0)\n\tcolnames(res)=causenames\n\trownames(res)=effectnames\n\t\t\n\tfor(gene in effectnames) {\n\t\taGene <- glmnet(data[,cause],data[,gene],alpha=1)$beta #return the the effects of all miRNAs on the gene\n    aGene=as.matrix(aGene)\n\t\taGene=rowMeans(aGene) # take the means of all values output from lasso    \n\t\tres[gene,]=aGene # assign the effects of all miRNAs on the gene to the result. \n\t}\n\nif(is.na(targetbinding)==FALSE){\n#query knowledge matrix from file\nedgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \nedgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\nedgeTargetScan<-edgeTargetScan!=0;\nedge=edgeTargetScan[effect,cause]\nres=res*edge\n}\n\nreturn(res)\n}\n\n#' miRNA target prediction with the Elastic-net regression coefficient method\n#' \n#' Calculate the Elastic-net regression coefficient of each pair of miRNA-mRNA,and return a matrix of correlation coefficients with columns are miRNAs and rows are mRNAs.\n#' @importFrom glmnet glmnet\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the Elastic-net regression coefficients. Columns are miRNAs, rows are mRNAs.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=Elastic(dataset, 1:3, 4:18) \n#' @references\n#' 1. Le, T.D., Zhang, J., Liu, L., and Li, J. (2015) Ensemble Methods for miRNA Target Prediction from Expression Data, under review.\n#' \n#' 2. Zou, H., & Hastie, T. (2005). Regularization and variable selection via the elastic net. J. R. Stat. Soc. Series B Stat. Methodol., 67, 301-320.\n#' @export \n## 11. Elastic-net ##\nElastic=function(datacsv, cause, effect, targetbinding=NA){\n # library(glmnet)\n\tif(is.character(datacsv)){\n\t\tdata=Read(datacsv)\n\t\t#data=data[,-1] # if the dataset have the sample names column, otherwise comment this out.\n\t} else {\n\t\tdata=datacsv #Assume there is no samplenames column and this is a data.frame.\n\t}\t\t\t\t\t\t\t#To allow both .csv data input or a matrix in R. This will help the IDAbootstrap, as IDA can run on sampling matrices.\n\tdata=scale(data) #standardise the data\n        header<-readHeader(datacsv)\n        num_miRNA<-length(cause)\n        miR<-header[1:num_miRNA]\n        mR<-header[-(1:num_miRNA)]\n\tdata=as.matrix(data)\n\t#print(data[1:5,])\n\tallnames=colnames(data)\n\tcausenames=allnames[cause]\n\teffectnames=allnames[effect]\n\tres=matrix(nrow=length(effectnames), ncol=length(causenames), 0)\n\tcolnames(res)=causenames\n\trownames(res)=effectnames\n\t\t\n\tfor(gene in effectnames) {\n\t\taGene <- glmnet(data[,cause],data[,gene],alpha=0.5)$beta #return the the effects of all miRNAs on the gene\n\t\taGene=as.matrix(aGene)\n    aGene=rowMeans(aGene) # take the means of all values output from lasso     \n\t\tres[gene,]=aGene # assign the effects of all miRNAs on the gene to the result. \n\t}\n\nif(is.na(targetbinding)==FALSE){\n#query knowledge matrix from file\nedgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \nedgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\nedgeTargetScan<-edgeTargetScan!=0;\nedge=edgeTargetScan[effect,cause]\nres=res*edge\n}\n\nreturn(res)\n}\n\n#' miRNA target prediction with the Z-score method\n#' \n#' Calculate the Z-score value of each pair of miRNA-mRNA, and return a matrix of values with columns are miRNAs and rows are mRNAs.\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the Z-score values. Columns are miRNAs, rows are mRNAs.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=Zscore(dataset, 1:3, 4:18) \n#' @references\n#' Prill, R.J., Marbach, D., Saez-Rodriguez, J., Sorger, P.K., Alexopoulos, L.G., Xue, X., Clarke, N.D., Altan-Bonnet, G. and Stolovitzky, G. (2010) Towards a rigorous assessment of systems biology models: the DREAM3 challenges. PLoS One, 5, e9202.\n#' @export \n## 12. Z-score ##\nZscore=function(datacsv, cause, effect, targetbinding=NA){\n\tdt=read.csv(datacsv, header=TRUE, sep=\",\")\n\tdt=scale(dt)\n        header<-readHeader(datacsv)\n        num_miRNA<-length(cause)\n        miR<-header[1:num_miRNA]\n        mR<-header[-(1:num_miRNA)]\n\n\teffectnames=colnames(dt)[effect]\n\tcausenames=colnames(dt)[cause]\n\tres=matrix(nrow=length(effectnames), ncol=length(causenames), 0)\n\tcolnames(res)=causenames\n\trownames(res)=effectnames\n\tcauses=dt[,cause]\n\teffects=dt[,effect]\n\t#zAB=(xBminA-meanB)/sdB\n\tfor (i in 1:length(cause)){\n\t\tfor (j in 1: length(effect)){\n\t\t\tindexminA=which(causes[,i]==min(causes[,i]))\n\t\t\txBminA=effects[indexminA,j]\n\t\t\txBminA=median(xBminA)\n\t\t\t#sdB=sd(effects[,j]) #if we standardise the sdB=1\n\t\t\t#meanB=mean(effects[,j]) if we standardise the mean is 0\n\t\t\t#zij=abs(xBminA-meanB)/sdB\n\t\t\tzij=abs(xBminA)\n\t\t\t\n\t\t\tres[j,i]=zij\n\t\t}\n\t}\n\nif(is.na(targetbinding)==FALSE){\n#query knowledge matrix from file\nedgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \nedgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\nedgeTargetScan<-edgeTargetScan!=0;\nedge=edgeTargetScan[effect,cause]\nres=res*edge\n}\n\nreturn(res)\n}\n\n#' miRNA target prediction with the ProMISe method\n#' \n#' Calculate the ProMISe score of each pair of miRNA-mRNA, and return a matrix of values with columns are miRNAs and rows are mRNAs.\n#' @importFrom Roleswitch roleswitch\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param targetbinding the putative target, e.g. \"TargetScan.csv\". If targetbinding is not specified, only expression data is used.\n#' If targetbinding is specified, the prediction results using expression data with be intersected with the interactions in the target binding file.\n#' @return A  matrix that includes the ProMISe scores. Columns are miRNAs, rows are mRNAs.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' results=ProMISe(dataset, 1:3, 4:18) \n#' @references\n#' Li, Y., Liang, C., Wong, K.C., Jin, K., and Zhang, Z. (2014). Inferring probabilistic miRNA - mRNA interaction signatures in cancers: a role-switch approach. Nucleic Acids Res., 42, e76-e76.\n#' @export \n## 13. ProMISe ##\nProMISe=function(datacsv, cause, effect, targetbinding=NA){\n  # library(\"Roleswitch\")\n  dt<-Read(datacsv)\n  dd<-colMeans(dt)\n  stdData<-as.matrix(dd)\n  header<-readHeader(datacsv)\n  num_miRNA<-length(cause)\n  miR<-header[1:num_miRNA]\n  mR<-header[-(1:num_miRNA)]\n  \n  x.o<-matrix(stdData[effect,],dimnames=list(c(1:length(effect)),\"mRNA\"))\n  z.o<-matrix(stdData[cause,],dimnames=list(c(1:length(cause)),\"miRNA\"))\n  c<-matrix(1,length(effect),length(cause)) #Generate ones matrix\n  rownames(c)<-c(1:length(effect))\n  colnames(c)<-c(1:length(cause))\n  \n  rMatrix <- roleswitch(x.o,z.o,c)$p.xz # Calculate ProMISe probabilistic\n  rownames(rMatrix) <- colnames(dt)[effect]\n  colnames(rMatrix) <- colnames(dt)[cause]\n  \n  if(is.na(targetbinding)==FALSE){\n    #query knowledge matrix from file\n    edgeTargetScan<-queryTargetFile(miR,mR,targetbinding); \n    edgeTargetScan<-edgeTargetScan+t(edgeTargetScan);\n    edgeTargetScan<-edgeTargetScan!=0;\n    edge=edgeTargetScan[effect,cause]\n    rMatrix=rMatrix*edge\n  }\n  \n  return(rMatrix)\n}\n\n\n#' Extract top k miRNA-mRNA interactions \n#' \n#' Rank the miRNA-mRNA interactions based on absolute values of the correlations/scores/causal effects, and return\n#' the topk interactions.\n#' @param cormat the correlation matrix that need to be extracted with columns are miRNAs and rows are mRNAs\n#' @param topk the number of interactions that need to be extracted.\n#' @return topk interactions \n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' EMTresults=Pearson(dataset, 1:3, 4:18)\n#' top10=Extopk(EMTresults, 10)\n#' @export\nExtopk <- function(cormat,topk){\n          mir<-ncol(cormat)\n          gene<-nrow(cormat)\n          mirname<-colnames(cormat)\n          mirname = gsub(\"\\\\.\", \"-\", mirname)  # replace \".\" with \"-\" for miRNA\n          for(index in 1:length(mirname)){\n          if(substr(mirname, nchar(mirname),nchar(mirname))[index]==\"-\") {\n\t          substring(mirname[index], nchar(mirname[index]), nchar(mirname[index]))=\"*\" \n                  }\n          }\n          genename<-rownames(cormat)\n          Result<-matrix(-1,ncol=4,nrow=mir*gene)\n          n<-0\n          for(i in 1:mir){\n                   for(j in 1:gene){\n                       n<-(n+1)\n                       Result[n, 1] <- mirname[i]\n                       Result[n, 2] <- genename[j]\n                       Result[n, 3] <- cormat[j,i]\n                       Result[n, 4] <- abs(as.numeric(Result[n, 3])) # Calculate absolute value\n                }\n           } \n           TrResult <- Result[sort.list(as.numeric(Result[,4]),decreasing=TRUE),] #Rank the whole interations by decreasing the absolute value\n           \n           return(TrResult[1:topk,]) # Extract top k miRNA-mRNA interactions\n        \t\n}      \n\n\n#' Ensemble method for miRNA target prediction using Borda count election\n#' \n#' Use the Borda count election method to integrate the rankings from different miRNA target prediction methods\n#' @param listCEmatrices a list of matrices that include the correlation coefficients/causal effects/scores resulting from different target prediction methods\n#' @return a matrix of ranking scores (averaging all the rankings from different methods). Columns are miRNAs and rows are mRNAs\n#' @examples\n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' ps=Pearson(dataset, cause=1:3, effect=4:18)\n#' ida=IDA(dataset, cause=1:3, effect=4:18)\n#' borda=Borda(list(ps, ida))\n#' @references\n#' 1. Le, T.D., Zhang, J., Liu, L., and Li, J. (2015) Ensemble Methods for miRNA Target Prediction from Expression Data, Plos ONE.\n#' \n#' 2. Marbach, D., Costello, J.C., Kuffner, R., Vega, N.M., Prill, R.J., Camacho, D.M., Allison, K.R. and DREAM5 Consortium (2012). Wisdom of crowds for robust gene network inference. Nat. Methods, 9, 796-804.\n#' @export\n\nBorda=function(listCEmatrices){\nnoMethods=length(listCEmatrices)\neffectnames=rownames(listCEmatrices[[1]])\ncausenames=colnames(listCEmatrices[[1]])\nres=matrix(nrow=length(effectnames), ncol=length(causenames), 0)\ncolnames(res)=causenames\nrownames(res)=effectnames\n\nfor(i in 1:noMethods){ # for each CEmatrix from a method\n\tfor (j in 1:length(causenames)){ #for each miRNA\n\t\tcormat=listCEmatrices[[i]][,j] #extract the corelation values\n\t\tcormat=cormat[order(-abs(cormat))] # sort based on absolute values\n\t\tfor(k in 1:length(cormat)){cormat[k]=k} # change the correlation values by the ranking\n\t\trn=names(cormat) # take the genenames\n\t\t\n\t\tfor(gene in rn){ #for each gene in the sorted matrix\n\t\t\tres[gene, j]=res[gene, j]+cormat[gene] #add up the current rankings of the possition (gene, miRNA)\n\t\t}\n\t}\n}\nres=res/noMethods #take the average rankings\nres=length(effectnames)/res #revert the rankings as bRank will sort the rankings as if correlation.\n}\n\n#' Ensemble method for miRNA target prediction using Borda count election with topk targets\n#' \n#' Use the Borda count election method to integrate the rankings from different miRNA target prediction methods, but only topk targets of each miRNA are included\n#' in the calculation. The targets outside the topk will be assigned a large and fixed rank, e.g. number of genes in the dataset.\n#' @param listCEmatrices a list of matrices that include the correlation/causal effects/scores resulting from a target prediction method\n#' @param topk number of targets of a miRNA to be included in the calculation (Borda count election)\n#' @return a matrix of ranking scores (averaging all the rankings from different methods). Columns are miRNAs and rows are mRNAs\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' ps=Pearson(dataset, cause=1:3, effect=4:18)\n#' ida=IDA(dataset, cause=1:3, effect=4:18)\n#' borda=BordaTopk(list(ps, ida), topk=10)\n#' @references\n#' Le, T.D., Zhang, J., Liu, L., and Li, J. (2015) Ensemble Methods for miRNA Target Prediction from Expression Data, Plos ONE.\n#' @export\nBordaTopk=function(listCEmatrices, topk){\nnoMethods=length(listCEmatrices)\neffectnames=rownames(listCEmatrices[[1]])\ncausenames=colnames(listCEmatrices[[1]])\nres=matrix(nrow=length(effectnames), ncol=length(causenames), 0)\ncolnames(res)=causenames\nrownames(res)=effectnames\nnoGenes=nrow(listCEmatrices[[1]])\nfor(i in 1:noMethods){ # for each CEmatrix from a method\n\tfor (j in 1:length(causenames)){ #for each miRNA\n\t\tcormat=listCEmatrices[[i]][,j] #extract the corelation values\n\t\tcormat=cormat[order(-abs(cormat))] # sort based on absolute values\n\t\tfor(k in 1:length(cormat)){cormat[k]=k} # change the correlation values by the ranking\n\t\trn=names(cormat) # take the genenames\n\t\t\n\t\tfor(gene in rn){ #for each gene in the sorted matrix\n\t\t\tif(cormat[gene]>topk) cormat[gene]=noGenes\n\t\t\tres[gene, j]=res[gene, j]+cormat[gene] #add up the current rankings of the possition (gene, miRNA)\n\t\t}\n\t}\n}\nres=res/noMethods #take the average rankings\nres=length(effectnames)/res #revert the rankings as bRank will sort the rankings as if correlation.\n}\n\n\n\nReOrder=function(topkList){\n   \n   ####### preprocessing the list of topk results #######\n   topkList = as.matrix(topkList, ncol=3);\n   if(nrow(topkList)<1 || length(topkList[,3]>0)==0 || length(topkList[,3]<0)==0)   return(data.frame(topkList));\n   \n   ####### sort the values in increasing order ########\n   val = as.numeric(topkList[,3]);  \n   val = sort(val, index.return=TRUE, decreasing=FALSE)\n\n   ####### obtain the negative values ########\n   ni = val$ix[which(val$x<0)] # the index of negative values in Val;\n   pi = val$ix[length(val$x):(length(ni)+1)] # the index of positive values in Val\n\n   return(data.frame(topkList[c(ni, pi), ]))\n}\n\n\n#' Extract topk predicted targets of a miRNA\n#' Rank all the targets of a miRNA and extract the topk targets\n#' @param CEmatrix the matrix of correlation/causal effect/score results with columns are miRNAs and rows are mRNAs\n#' @param causeIndex the column index of the miRNA that we would like to extract\n#' @param topk the number of targets being extracted\n#' @param downreg if TRUE the negative correlation/causal effect/score will be on the top of the ranking. This is to\n#' favour the negative regulations. \n#' @return a matrix with 3 columns, where the first column contains the miRNA, the second column contains the mRNAs and the last column contains the correlations/causal effects/scores\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' ps=Pearson(dataset, cause=1:3, effect=4:18)\n#' miR200aTop10 = bRank(ps, 3, 10, TRUE)\n#' @export\n\nbRank=function(CEmatrix, causeIndex, topk, downreg=TRUE){\n\nmiRNAnames=colnames(CEmatrix)\nmRNAnames=rownames(CEmatrix)\n\nc1=rep(miRNAnames[causeIndex], length(mRNAnames))\ncorMat=CEmatrix[,causeIndex]\nresult=cbind(c1,mRNAnames, corMat)\nrownames(result)=NULL\ncolnames(result)=c(\"miRNA\", \"mRNA\", \"Correlation\")\n#remove quotes\nresult=data.frame(result)\nresult[,3]=as.numeric(as.character(result[,3]))\n\n#cat(\"numberof genes in result:\", nrow(result), \"\\n\")\nresult=result[order(-(abs(result[,3]))),]\nresult=result[!duplicated(result[,2]),]\n#cat(\"number of genes in the ranking list after removing dulicates\", nrow(result), \"\\n\")\n\nresult=result[1:topk,]\nresult[, 1] = gsub(\"\\\\.\", \"-\", result[, 1])  # replace \".\" with \"-\" for miRNA\nif(substr(result[ ,1], nchar(result[,1]), nchar(result[,1]))[1]==\"-\") {\n\tsubstring(result[,1], nchar(result[,1]), nchar(result[,1]))=\"*\" \n}\n# if the last character is - then change to *, e.g. hsa-miR-7-1*\n#result[, 2] = gsub(\"\\\\.\", \"-\", result[, 2])  # replace \".\" with \"-\" for mRNA\nif(downreg) result=ReOrder(result)\n#print(result[1:5,])\nreturn(result)\n}\n\n\n############# Validation function ###### \n#' Validate the targets of a miRNA\n#' \n#' Given the predicted target of a miRNA, the function returns a list of targets that are experimentally confirmed\n#' based on the provided ground truth. Users can provide their own ground truth or use the built-in ground truth \n#' which is the union of Tarbase, miRTarbase, miRecords, and miRWalk. \n#' @param topkList a matrix with 3 columns. The first column is the miRNA name, the second contains the target mRNAs, and the third contains the correlation values/ causal effects/ scores\n#' @param datacsv the ground truth for the validation. The ground truth is a matrix with 2 columns, where the first column\n#' is the miRNA and the second is the mRNA.\n#' @return a matrix in the same format of the input matrix put only contains the confirmed interactions.\n#' @examples \n#' dataset=system.file(\"extdata\", \"ToyEMT.csv\", package=\"miRLAB\")\n#' ps=Pearson(dataset, cause=1:3, effect=4:18)\n#' miR200aTop10=bRank(ps, 3, 10, TRUE)\n#' groundtruth=system.file(\"extdata\", \"Toygroundtruth.csv\", package=\"miRLAB\")\n#' miR200aTop10Confirmed = Validation(miR200aTop10, groundtruth)\n#' @export\nValidation=function(topkList, datacsv){\n\t\n####### preprocessing the list of topk results #######\n\ttopkList = as.matrix(topkList, ncol=3);\n\tif(nrow(topkList)<1) stop(\"No data in the input\")\n    \n####### read the validation data from file ########\n        dt=read.csv(datacsv, header=TRUE, sep=\",\")\n\t\n####### get the validation lists from the data ######\n\t        \n        dt = paste(dt[, 1], dt[, 2], sep=\" \");\n        tmp= paste(topkList[, 1], topkList[, 2], sep=\" \");\t  \t\n\tresult=topkList[which(tmp %in% dt), ] \n        \n\t\n\tif(is.matrix(result)){\n\t\tresult=data.frame(result)\n\t\tresult[,3]=as.numeric(as.character(result[,3]))\n\t\tNoConfimred=nrow(result)\n\t} else {\n\t\tresult=as.matrix(result)\n\t\tresult=t(result)\n\t\tresult=data.frame(result)\n\t\tresult[,3]=as.numeric(as.character(result[,3]))\n\t\tNoConfimred=nrow(result)\n\t}\n\t\n\treturn(list(result, NoConfimred))\n}\n\n#' Validate the targets of a miRNA using transfection data\n#' \n#' Given the predicted target of a miRNA, the function returns a list of targets that are  confirmed\n#' based on the curated transfection data. Users need to download the file logFC.imputed.rda from nugget.unisa.edu.au/Thuc/miRLAB/ and place it in the working directory (this file is obtained from the TargetScoreData package)\n#' @param topkList a matrix with 3 columns. The first column is the miRNA name, the second contains the target mRNAs, and the third contains the correlation values/ causal effects/ scores\n#' @param LFC the log fold change threshold. The targets that have the absolute value of log fold change greater than the LFC\n#' will be regarded as the confirmed targets.\n#' @return a matrix in the same format of the input matrix put only contains the confirmed interactions.\n#' @examples \n#dataset=system.file(\"extdata\", \"EMT35.csv\", package=\"miRLAB\")\n#' print(\"ps=Pearson(dataset, cause=1:35, effect=36:1189)\")\n#' print(\"miR200aTop100=bRank(ps, 11, 100, TRUE)\")\n#' print(\"miR200aTop100Confirmed = ValidationT(miR200aTop100, 1.0)\")\n#' @export\n#' @references\n#' 1. Le, T.D., Zhang, J., Liu, L., and Li, J. (2015) Ensemble Methods for miRNA Target Prediction from Expression Data, under review.\n#' \n#' 2. Li Y, Goldenberg A, Wong K and Zhang Z (2014). A probabilistic approach to explore human microRNA targetome using microRNA-overexpression data and sequence information. Bioinformatics, 30(5), pp. 621-628. http://dx.doi.org/10.1093/bioinformatics/btt599.\n\n\nValidationT=function(topkList, LFC){\n #get all transfection data from TargetScoreData package and present in the format of Tarbase.\n #the rows with LFC <= LFC will be discarded\n dt=system.file(\"extdata\", \"Transfection_data_summary.csv\", package=\"miRLAB\")\n Transfection=read.csv(dt, header=TRUE, sep=\",\")\n logFC.imputed=c()\n if(!file.exists(\"logFC.imputed.rda\"))\n   stop(\"Please download the transfection data from nugget.unisa.edu.au/Thuc/miRLAB/logFC.imputed.rda for validation. \n       If you would like to use experimentally confirmed data only, please use the Validation function\")\n load(\"./logFC.imputed.rda\")\n td=logFC.imputed\n \n topkList = as.matrix(topkList, ncol=3);\n stopifnot(nrow(topkList)>0)\n miN = unique(topkList[, 1]) # get the unique names of miRNA\n mind= NULL;\n for(i in 1:length(miN))\n\tmind = c(mind, which(Transfection[,1]==miN[i]))  #get the index of miRNA from the validation data   \n #print(mind)\n if(length(mind)==0){\n\t#cat(\"This miRNA is not in the tranfection database\", \"\\n\")\n\treturn(list(NULL, 0))\n}\t\n rn=rownames(td) # take the genenames\n td = td[,mind]      # get a small validation data from the original one, a new list\n \n if(length(mind)>1) td=rowMeans(td)\t # take the average of LFCs\n \t\t \n#decorate the table\n groundtruth=cbind(rep(miN, length(rn)), rn, td)\n rownames(groundtruth)=NULL\n colnames(groundtruth)=c(\"miRNA\", \"mRNA\", \"LFC\")\n groundtruth=data.frame(groundtruth)\n groundtruth[,3]=as.numeric(as.character(groundtruth[,3]))\n groundtruth=groundtruth[abs(groundtruth[,3])>LFC,]       #LFC<-1 using groundtruth=groundtruth[groundtruth[,3]<-LFC,]\n groundtruth=groundtruth[,1:2]\n \n groundtruth = paste(groundtruth[, 1], groundtruth[, 2], sep=\" \");\n tmp= paste(topkList[, 1], topkList[, 2], sep=\" \");\n result=topkList[which(tmp %in% groundtruth), ]\n \n #Decorate the result table, if only one row it is not a matrix. If it is a matrix we just remove the \"\" in data\n if(is.matrix(result)){\n\tresult=data.frame(result)\n\tresult[,3]=as.numeric(as.character(result[,3]))\n\tNoConfimred=nrow(result)\n  } else {\n\t\tresult=as.matrix(result)\n\t\tresult=t(result)\n\t\tresult=data.frame(result)\n\t\tresult[,3]=as.numeric(as.character(result[,3]))\n\t\tNoConfimred=nrow(result)\n  }\n  #cat(\"Number of confirmed genes for  \",miN, \"is: \", NoConfimred, \"\\n\")\n\t\n  return(list(result, NoConfimred))\n\n \n}\n\n#' Validate the targets of all miRNA using both experimentally confirmed and transfection data\n#' \n#' Given the predicted target of all miRNA, the function returns a list of targets of each miRNA that are  confirmed\n#' based on the experimentally validated interactions or curated transfection data. Users need to download the file logFC.imputed.rda from nugget.unisa.edu.au/Thuc/miRLAB/ and place it in the working directory (this file is obtained from the TargetScoreData package)\n#' @param CEmatrix the matrix of correlation/causal effects/scores with columns are miRNAs and rows are mRNAs\n#' @param topk the number of targets of each miRNA that are being validated. \n#' @param groundtruth the csv file containing the ground truth.\n#' @param LFC the log fold change threshold for the transfection data. The targets that have the absolute value of log fold change greater than the LFC\n#' will be regarded as the confirmed targets.\n#' @param downreg if TRUE the negative correlation/causal effect/score values will be ranked on the top of the ranking. This is to favour the down regulations.\n#' @return a list of matrices that contains the confirmed interactions by both provided ground truth and built-in transfection data.\n#' @examples \n#' print(\"ps=Pearson(dataset, cause=1:3, effect=4:18)\")\n#' print(\"results=ValidateAll(ps, 10, groundtruth, LFC=0.5, downreg=TRUE)\")\n#' @export\n# \\dontrun{\n# dataset=system.file(\"extdata\", \"ToyEMT35.csv\", package=\"miRLAB\")\n# ps=Pearson(dataset, cause=1:3, effect=4:18)\n# groundtruth=system.file(\"extdata\", \"groundtruth.csv\", package=\"miRLAB\")\n# results=ValidateAll(ps, 10, groundtruth, LFC=0.5, downreg=TRUE)\n# }\nValidateAll=function(CEmatrix, topk, groundtruth, LFC, downreg=TRUE){\n#CEmatrix: the results from a computational method in a matrix format. columns are miRNAs. Rows are genes.\n#causes: the column indices of the causes in the dataset or in the CEMatrix.\n#Top k gene of each miRNA we would like to extract for validation.\n#Groundtruth is the experimentally validated database in .csv format.\n#LFC: log2 fold-change threshold for identifying the groundtruth using miRNA transfection data.\nif(!file.exists(\"logFC.imputed.rda\"))\n  stop(\"Please download the transfection data from nugget.unisa.edu.au/Thuc/miRLAB/logFC.imputed.rda for validation. \n       If you would like to use experimentally confirmed data only, please use the Validation function\")\n causes=1:ncol(CEmatrix)\n NoExpConfirmed=c()\n NoTransConfirmed=c()\n names=c('miRNA','mRNA','Correlation')\n K1=c() #ground truth experiment\n ResultK1=matrix(,ncol=3)\n colnames(ResultK1)=names\n K2=c() #ground truth transfection\n ResultK2=matrix(,ncol=3)\n colnames(ResultK2)=names\n pE=c() #pvalue for experiment\n pT=c() #pvalue for transfection\n S=nrow(CEmatrix)\n\tfor (i in causes){\n\t\tmiRtopk=bRank(CEmatrix, i, topk, downreg)\n\t\tmiRall=bRank(CEmatrix, i, S)\n\t\t#cat(\"Validate the prediction using experimentally confirmed database \", \"\\n\")\n\t\ttemp1=Validation(miRtopk, groundtruth)\n\t\ttemp2=Validation(miRall, groundtruth)\n\t\tpvalE=1-phyper((temp1[[2]]-1), temp2[[2]], (S-temp2[[2]]), topk)\n\t\tpE=c(pE, pvalE)\n\t\t\n\t\tcat(\"EXPERIMENT:  \", colnames(CEmatrix)[i], \": \", temp1[[2]], \"with \", temp2[[2]], \" in the groundtruth. pvalue: \",pvalE, \"\\n\")\n\t\tNoExpConfirmed=c(NoExpConfirmed,temp1[[2]]) # sum will be x in hypergeometric test.\n\t\tK1=c(K1,temp2[[2]])\n                if(temp1[[2]]>0)  ResultK1=rbind(ResultK1,temp1[[1]])\n                     \n \t\t\n\t\t#cat(\"Validate the prediction using transfection data \", \"\\n\")\n\t\ttemp3=ValidationT(miRtopk, LFC)\n\t\ttemp4=ValidationT(miRall, LFC)\n\t\tpvalT=1-phyper((temp3[[2]]-1), temp4[[2]], (S-temp4[[2]]), topk)\n\t\tpT=c(pT, pvalT)\n\t\tcat(\"TRANSFECTION:  \", colnames(CEmatrix)[i], \": \", temp3[[2]], \"with \", temp4[[2]], \" in the groundtruth. pvalue: \", pvalT, \"\\n\")\n\t\tNoTransConfirmed=c(NoTransConfirmed,temp3[[2]]) # sum will be x in the hypergeometric test.\n\t\tK2=c(K2,temp4[[2]]) \n                \n\t\tif(temp3[[2]]>0) ResultK2=rbind(ResultK2,temp3[[1]])\n\t\t\n\t}\n\tpvalueE=1-phyper((sum(NoExpConfirmed)-1), sum(K1), (S*ncol(CEmatrix)-sum(K1)), topk*ncol(CEmatrix))\n\tpvalueT=1-phyper((sum(NoTransConfirmed)-1), sum(K2), (S*ncol(CEmatrix)-sum(K2)), topk*ncol(CEmatrix))\n\t\n\tcat(\"number of confirms by experiments: \", sum(NoExpConfirmed), \", pvalue: \", pvalueE, \". By transfection \", sum(NoTransConfirmed), \", pvalue: \", pvalueT, \"\\n\")\n\tcat(\"groundtruths in experiments: \", sum(K1), \", and in transfection \", sum(K2), \"\\n\")\n\tresult=list(ResultK1[2:nrow(ResultK1),], cbind(K1, NoExpConfirmed, pE), ResultK2[2:nrow(ResultK2),], cbind(K2, NoTransConfirmed, pT))\n}\n\n\n## Read external results ##\n#' Read results from other methods\n#' \n#' Read the results predicted by external methods (methods that are not in this package and may not be implemented in R). Consequently, we can compare the results\n#' predicted by the external methods and results predicted by the methods in the miRLAB package.\n#' @param datacsv the input dataset in csv format\n#' @param cause the column range that specifies the causes (miRNAs), e.g. 1:35\n#' @param effect the column range that specifies the effects (mRNAs), e.g. 36:2000\n#' @param ExtCEcsv score matrix predicted by an external matrix with columns are miRNAs and rows are mRNAs.\n#' @return a matrix of scores predicted by an external matrix and ready for further validation and comparison tasks.\n#' @examples \n#' print(\"GenemiR=ReadExtResult(dataset, cause=1:3, effect=4:18, 'genemirresults.csv')\")\n#' @export\nReadExtResult=function(datacsv, cause, effect,  ExtCEcsv){\n\tdataset=read.csv(datacsv, header=TRUE, sep=\",\")\n\tgenenames=colnames(dataset)\n\tcausenames=genenames[cause]\n\teffectnames=genenames[effect]\n\tExtmatrix=read.csv(ExtCEcsv, header=FALSE, sep=\",\")\n\tcolnames(Extmatrix)=causenames\n\trownames(Extmatrix)=effectnames\n\treturn(Extmatrix)\n\t\n}\n\n#delete experiment function\n\n## Compare the validation results of 13 built-in methods ##\nfilterAndCompare=function(allresults, noVal){\n\t#allresults: the results from all methods generated from experiment function. This is a list\n\t#noVal: number of confirmed targets in each method (threshold) to filter. Records (miRNA) with less than this will be removed\n\tExpResult=allresults[[1]]\n\tTransResult=allresults[[2]]\n\ttemp1=apply(ExpResult, 1, function(x) all(x[c(2,4,6,8,10,12,14,16,18,20,22,24,26)]>(noVal-1)))\n\tExpResult=ExpResult[temp1,]\n\ttemp2=apply(TransResult, 1, function(x) all(x[c(2,4,6,8,10,12,14,16,18,20,22,24,26)]>(noVal-1)))\n\tTransResult=TransResult[temp2,]\n\t###If else to incase only one record. In that case the result is not a matrix\n\tif(is.matrix(ExpResult)){\n\t\tExpResult=ExpResult[,c(2,4,6,8,10,12,14,16,18,20,22,24,26)]\n\t\tcolnames(ExpResult)=c( \"Pearson\", \"Spearman\", \"Kendall\", \" Dcov\", \"Hoeffding\", \"MI\", \"IDA\", \"MIC\", \"RDC\", \"Lasso\", \"Elastic\", \"Z-score\", \"ProMISe\")\n\t} else {\n\t\ttt=as.matrix(ExpResult)\n\t\tExpResult=t(tt)\n\t\tExpResult=ExpResult[,c(2,4,6,8,10,12,14,16,18,20,22,24,26)]\n\t\tnames(ExpResult)=c( \"Pearson\", \"Spearman\", \"Kendall\", \" Dcov\", \"Hoeffding\", \"MI\", \"IDA\", \"MIC\", \"RDC\", \"Lasso\", \"Elastic\", \"Z-score\", \"ProMISe\")\n\t}\n\t\n\tif(is.matrix(TransResult)){\n\t\tTransResult=TransResult[,c(2,4,6,8,10,12,14,16,18,20,22,24,26)]\n\t\tcolnames(TransResult)=c( \"Pearson\", \"Spearman\", \"Kendall\", \" Dcov\", \"Hoeffding\", \"MI\", \"IDA\", \"MIC\", \"RDC\", \"Lasso\", \"Elastic\", \"Z-score\", \"ProMISe\")\n\t} else {\n\t\ttt=as.matrix(TransResult)\n\t\tTransResult=t(tt)\n\t\tTransResult=TransResult[,c(2,4,6,8,10,12,14,16,18,20,22,24,26)]\n\t\t#print(TransResult)\n\t\tnames(TransResult)=c( \"Pearson\", \"Spearman\", \"Kendall\", \" Dcov\", \"Hoeffding\", \"MI\", \"IDA\", \"MIC\", \"RDC\", \"Lasso\", \"Elastic\", \"Z-score\", \"ProMISe\")\n\t}\n\tif(is.matrix(ExpResult)){\n\t\tnumberExpResult=apply(ExpResult, 2, sum)\n\t\tranking=apply(ExpResult, 1, function(i) rank(i))\n\t\tranking=t(ranking)\n\t\trankExpResult=apply(ranking, 2, sum)\n\t}\n\tif(is.matrix(TransResult)){\n\t\tnumberTransResult=apply(TransResult, 2, sum)\t\n\t\trankingT=apply(TransResult, 1, function(i) rank(i))\n\t\trankingT=t(rankingT)\n\t\trankTransResult=apply(rankingT, 2, sum)\n\t}\n\tif(is.matrix(ExpResult)){\n\t\tExp=list(ExpResult, numberExpResult, rankExpResult)\n\t} else Exp=ExpResult\n\t\n\tif(is.matrix(TransResult)){\n\t\tTrans=list(TransResult, numberTransResult, rankTransResult)\n\t} else Trans=TransResult\n\t\n\tresult=list(Exp, Trans)\n}\n\n## Enrichment analysis including GO and KEGG enrichment analysis using two functions: GOBPenrichment and KEGGenrichment ##\n# The input is a list of gene symbols. For example: Genes <- c(\"AREG\", \"FKBP5\", \"CXCL13\", \"KLF9\", \"ZC3H12A\", \"P4HA1\", \"TLE1\", \"CREB3L2\", \"TXNIP\", \"PBX1\", \"GJA1\", \"ITGB8\", \"CCL3\", \"CCND2\", \"KCNJ15\", \"CFLAR\", \"CXCL10\", \"CYSLTR1\", \"IGFBP7\", \"RHOB\", \"MAP3K5\", \"CAV2\", \"CAPN2\", \"AKAP13\", \"RND3\", \"IL6ST\", \"RGS1\", \"IRF4\", \"G3BP1\", \"SEL1L\", \"VEGFA\", \"SMAD1\", \"CCND1\", \"CLEC3B\", \"NEB\", \"AMD1\", \"PDCD4\", \"SCD\", \"TM2D3\", \"BACH2\", \"LDLR\", \"BMPR1B\", \"RFXAP\", \"ASPH\", \"PTK2B\", \"SLC1A5\", \"ENO2\", \"TRPM8\", \"SATB1\", \"MIER1\", \"SRSF1\", \"ATF3\", \"CCL5\", \"MCM6\", \"GCH1\", \"CAV1\", \"SLC20A1\")\n#@import GSEABase @import Category\n## GO BP enrichment analysis, Cutoff is normally set to 0.05 ##\n#' Functional enrichment analysis\n#' \n#' GO BP enrichment analysis for a gene list\n# @importMethodsFrom AnnotationDbi mget Lkeys get\n# @importFrom org.Hs.eg.db org.Hs.egSYMBOL2EG org.Hs.egGO org.Hs.egSYMBOL\n# @import GOstats \n# @import Category \n#' @param Genes a list of gene symbols\n#' @param Cutoff the significant level, e.g. 0.05\n#' @examples\n#'  print(\"result = GOBPenrichment(genelist, 0.05)\")\n#' @return a list of GO terms for the genes\n#' @export\n#' @references\n#' Ashburner, M., Ball, C.A., Blake, J.A., Botstein, D., Butler, H., Cherry, J.M., Davis, A.P., Dolinski, K., Dwight, S.S., Eppig, J.T., Harris, M.A., Hill, D.P., Issel-Tarver, L., Kasarskis, A., Lewis, S., Matese, J.C., Richardson, J.E., Ringwald, M., Rubin, G.M. and Sherlock, G. (2000) Gene Ontology: tool for the unification of biology. Nat. Genet., 25, 25-29.\nGOBPenrichment <- function(Genes, Cutoff){\n  \nif(requireNamespace(\"AnnotationDbi\", quitely=TRUE)) {\n  EntrezIDs <- AnnotationDbi::mget(Genes, org.Hs.eg.db::org.Hs.egSYMBOL2EG, ifnotfound=NA)\n  EntrezIDs <- as.character(EntrezIDs)\n  GOAnnotation <- AnnotationDbi::get(\"org.Hs.egGO\")\n  Universe <- AnnotationDbi::Lkeys(GOAnnotation)\n\n  Params <- new(\"GOHyperGParams\",\n                  geneIds=EntrezIDs,\n                  universeGeneIds=Universe,\n                  annotation=\"org.Hs.eg.db\",\n                  ontology=\"BP\",\n                  pvalueCutoff=Cutoff,\n                  conditional=FALSE,\n                  testDirection=\"over\")\n}\nif(requireNamespace(\"GOstats\", quitely=TRUE)) {\n  Over <- GOstats::hyperGTest(Params)\n}\nif(requireNamespace(\"Category\", quitely=TRUE)) {\n  Glist <- Category::geneIdsByCategory(Over)\n}\nif(requireNamespace(\"AnnotationDbi\", quitely=TRUE)){\nGlist <- sapply(Glist, function(.ids) {\n \t.sym <- AnnotationDbi::mget(.ids, envir=org.Hs.eg.db::org.Hs.egSYMBOL, ifnotfound=NA)\n \t.sym[is.na(.sym)] <- .ids[is.na(.sym)]\n \tpaste(.sym, collapse=\";\")\n \t})\nBP <- summary(Over)\nBP$Symbols <- Glist[as.character(BP$GOBPID)]\n# Adjust p-value using Benjamini & Hochberg (BH) method\nBP$adjustPvalue <-p.adjust(BP$Pvalue, \"BH\", length(BP$Pvalue))\n# write.csv(BP,'BPResult.csv')\n}\n\nreturn(BP)\n}\n\n## KEGG enrichment analysis, Cutoff is normally set to 0.05 ##\n## GO BP enrichment analysis, Cutoff is normally set to 0.05 ##\n#' Functional enrichment analysis\n#' KEGG enrichment analysis for a gene list\n# @importMethodsFrom AnnotationDbi mget Lkeys get\n# @import GOstats \n# @import Category \n# @importFrom org.Hs.eg.db org.Hs.egSYMBOL2EG org.Hs.egPATH org.Hs.egSYMBOL\n#' @param Genes a list of gene symbols\n#' @param Cutoff the significant level, e.g. 0.05\n#' @examples\n#'  print(\"result = KEGGenrichment(genelist, 0.05)\") \n#' @return a list of pathways for the genes\n#' @export\n#' @references\n#' Kanehisa, M. and Goto, S. (2000) KEGG: kyoto encyclopedia of genes and genomes. Nucleic Acids Res., 28, 27-30.\n\nKEGGenrichment <- function(Genes, Cutoff){\n\n  if(requireNamespace(\"AnnotationDbi\", quitely=TRUE)){\nEntrezIDs <- AnnotationDbi::mget(Genes, org.Hs.eg.db::org.Hs.egSYMBOL2EG, ifnotfound=NA)\nEntrezIDs <- as.character(EntrezIDs)\nKEGGAnnotation <- AnnotationDbi::get(\"org.Hs.egPATH\")\nUniverse <- AnnotationDbi::Lkeys(KEGGAnnotation)\nParams <- new(\"KEGGHyperGParams\", \n                     geneIds=EntrezIDs, \n                     universeGeneIds=Universe, \n                     annotation=\"org.Hs.eg.db\", \n                     categoryName=\"KEGG\", \n                     pvalueCutoff=Cutoff,\n                     testDirection=\"over\")\n}\n\nif(requireNamespace(\"GOstats\", quitely=TRUE)){\n  Over <- GOstats::hyperGTest(Params)\n KEGG <- summary(Over)\n}\nif(requireNamespace(\"Category\", quitely=TRUE)){\n  Glist <- Category::geneIdsByCategory(Over)\n}\nif(requireNamespace(\"AnnotationDbi\", quitely=TRUE)){\nGlist <- sapply(Glist, function(.ids) {\n \t.sym <- AnnotationDbi::mget(.ids, envir=org.Hs.eg.db::org.Hs.egSYMBOL, ifnotfound=NA)\n \t.sym[is.na(.sym)] <- .ids[is.na(.sym)]\n \tpaste(.sym, collapse=\";\")\n \t})\nKEGG$Symbols <- Glist[as.character(KEGG$KEGGID)]\n# Adjust p-value using Benjamini & Hochberg (BH) method\nKEGG$adjustPvalue <-p.adjust(KEGG$Pvalue, \"BH\", length(KEGG$Pvalue))\n# write.csv(KEGG,'KEGGResult.csv')\n}\n\nreturn(KEGG)\n}\n\n#' Function for validate the results from all 12 methods.\n#' @param allmethods A list of results (matrix with columns are miRNA and rows are mRNAs). \n#' @param topk Top k targets of each miRNA that will be extracted for validation\n#' @param Expgroundtruth The ground truth in .csv file for validation\n#' @param LFC log fold-change for validating the results using transfection experiments\n#' @param downreg If set to TRUE the negative effects will have higher ranks than the positives.\n#' @return The validation results for all 12 methods \n#' @export\nexperiment=function(allmethods, topk, Expgroundtruth, LFC, downreg){\n  \n  psv=ValidateAll(allmethods[[1]], topk, Expgroundtruth, LFC, downreg)\n  spv=ValidateAll(allmethods[[2]], topk, Expgroundtruth, LFC, downreg)\n  kendallv=ValidateAll(allmethods[[3]], topk, Expgroundtruth, LFC, downreg)\n  dcovv=ValidateAll(allmethods[[4]], topk, Expgroundtruth, LFC, downreg)\n  hoeffdingv=ValidateAll(allmethods[[5]], topk, Expgroundtruth, LFC, downreg)\n  miv=ValidateAll(allmethods[[6]], topk, Expgroundtruth, LFC, downreg)\n  idav=ValidateAll(allmethods[[7]], topk, Expgroundtruth, LFC, downreg)\n # micv=ValidateAll(allmethods[[8]], topk, Expgroundtruth, LFC, downreg, TargetBinding)\n  rdcv=ValidateAll(allmethods[[8]], topk, Expgroundtruth, LFC, downreg)\n  lassov=ValidateAll(allmethods[[9]], topk, Expgroundtruth, LFC, downreg)\n  elasticv=ValidateAll(allmethods[[10]], topk, Expgroundtruth, LFC, downreg)\n  zsv=ValidateAll(allmethods[[11]], topk, Expgroundtruth, LFC, downreg)\n  promisev=ValidateAll(allmethods[[12]], topk, Expgroundtruth, LFC, downreg)\n  \n  #############genenames\n  miRs=colnames(allmethods[[1]])\n  #########decorate and return\n  result1= cbind(psv[[2]], spv[[2]][,2:3], kendallv[[2]][,2:3], dcovv[[2]][,2:3], hoeffdingv[[2]][,2:3], miv[[2]][,2:3], idav[[2]][,2:3], rdcv[[2]][,2:3], lassov[[2]][,2:3], elasticv[[2]][,2:3],zsv[[2]][,2:3], promisev[[2]][,2:3])\n  rownames(result1)=miRs\n  result2= cbind(psv[[4]], spv[[4]][,2:3], kendallv[[4]][,2:3], dcovv[[4]][,2:3], hoeffdingv[[4]][,2:3], miv[[4]][,2:3], idav[[4]][,2:3], rdcv[[4]][,2:3], lassov[[4]][,2:3], elasticv[[4]][,2:3],zsv[[4]][,2:3], promisev[[4]][,2:3])\n  rownames(result2)=miRs\n  result=list(result1, result2)\n  return(result)\n}\n\n## Compare the validation results of 13 built-in methods ##\n#' Filter and compare the validation results from 12 methods\n#' Keep the miRNAs that have at least noVal confirmed targets and compare the validation results from all methods.\n#' @param allresults the results from all methods generated from experiment function. This is a list.\n#' @param noVal Number of confirmed targets in each method (threshold) to filter. Records (miRNA) with less than this will be removed\n#' @return the validation results of all methods\n#' @examples\n#' print(\"result=filterAndCompare(allresults, 2)\")\n#' @export \nfilterAndCompare=function(allresults, noVal){\n  #allresults: the results from all methods generated from experiment function. This is a list\n  #noVal: number of confirmed targets in each method (threshold) to filter. Records (miRNA) with less than this will be removed\n  ExpResult=allresults[[1]]\n  TransResult=allresults[[2]]\n  temp1=apply(ExpResult, 1, function(x) all(x[c(2,4,6,8,10,12,14,16,18,20,22,24)]>(noVal-1)))\n  ExpResult=ExpResult[temp1,]\n  temp2=apply(TransResult, 1, function(x) all(x[c(2,4,6,8,10,12,14,16,18,20,22,24)]>(noVal-1)))\n  TransResult=TransResult[temp2,]\n  ###If else to incase only one record. In that case the result is not a matrix\n  if(is.matrix(ExpResult)){\n    ExpResult=ExpResult[,c(2,4,6,8,10,12,14,16,18,20,22,24)]\n    colnames(ExpResult)=c( \"Pearson\", \"Spearman\", \"Kendall\", \" Dcov\", \"Hoeffding\", \"MI\", \"IDA\", \"RDC\", \"Lasso\", \"Elastic\", \"Z-score\", \"ProMISe\")\n  } else {\n    tt=as.matrix(ExpResult)\n    ExpResult=t(tt)\n    ExpResult=ExpResult[,c(2,4,6,8,10,12,14,16,18,20,22,24)]\n    names(ExpResult)=c( \"Pearson\", \"Spearman\", \"Kendall\", \" Dcov\", \"Hoeffding\", \"MI\", \"IDA\", \"RDC\", \"Lasso\", \"Elastic\", \"Z-score\", \"ProMISe\")\n  }\n  \n  if(is.matrix(TransResult)){\n    TransResult=TransResult[,c(2,4,6,8,10,12,14,16,18,20,22,24)]\n    colnames(TransResult)=c( \"Pearson\", \"Spearman\", \"Kendall\", \" Dcov\", \"Hoeffding\", \"MI\", \"IDA\", \"RDC\", \"Lasso\", \"Elastic\", \"Z-score\", \"ProMISe\")\n  } else {\n    tt=as.matrix(TransResult)\n    TransResult=t(tt)\n    TransResult=TransResult[,c(2,4,6,8,10,12,14,16,18,20,22,24)]\n    #print(TransResult)\n    names(TransResult)=c( \"Pearson\", \"Spearman\", \"Kendall\", \" Dcov\", \"Hoeffding\", \"MI\", \"IDA\", \"RDC\", \"Lasso\", \"Elastic\", \"Z-score\", \"ProMISe\")\n  }\n  if(is.matrix(ExpResult)){\n    numberExpResult=apply(ExpResult, 2, sum)\n    ranking=apply(ExpResult, 1, function(i) rank(i))\n    ranking=t(ranking)\n    rankExpResult=apply(ranking, 2, sum)\n  }\n  if(is.matrix(TransResult)){\n    numberTransResult=apply(TransResult, 2, sum)\t\n    rankingT=apply(TransResult, 1, function(i) rank(i))\n    rankingT=t(rankingT)\n    rankTransResult=apply(rankingT, 2, sum)\n  }\n  if(is.matrix(ExpResult)){\n    Exp=list(ExpResult, numberExpResult, rankExpResult)\n  } else Exp=ExpResult\n  \n  if(is.matrix(TransResult)){\n    Trans=list(TransResult, numberTransResult, rankTransResult)\n  } else Trans=TransResult\n  \n  result=list(Exp, Trans)\n}\n\n#' Convert miRNA symbols from a miRBase version to another \n#' \n#' This function convert the miRNAs in the input file from the \"source\" miRBase version to the \"Target\" version. \n#' If users do not know the miRBase version of the input file, please set the source version to 0. The function will match the \n#' miRNAs in the input file to all miRBase versions to find the most likely miRBase version. Currently, we have versions 16-21.\n#' @param miRNAListFile the input file containing a list of miRNA symbols in csv format\n#' @param sourceV the miRBase version of the input miRNAs, e.g. 16. If users do not know the version, use 0.\n#' @param targetV the miRBase version that we want to convert into, e.g. 21.\n#' @return A csv file in the working directory containing the converted miRNA symbols.\n#' @examples \n#' miRs=system.file(\"extdata\", \"ToymiRs.csv\", package=\"miRLAB\")\n#' convert(miRs, 17, 21) \n#' @export \nconvert = function (miRNAListFile,sourceV,targetV) {\n  load(system.file(\"extdata\", \"database.RData\", package=\"miRLAB\"))\n  miRNAList = as.matrix( read.csv( miRNAListFile ,header = FALSE) )\n  sourceName = miRNAList\n  sourceVersion = c()\n  targetName = c()\n  targetVersion = c()\n  \n  if (sourceV != 0) # have the source version\n  {\n    location = match( miRNAList, all[,sourceV-14] )\n    isNA = is.na(location)\n    targetVersion[which(!isNA)] = targetV\n    targetVersion[which(isNA)] = NA\n    targetName = all[location, targetV-14]\n    sourceVersion = rep(sourceV,length(miRNAList))\n  }else \n  {\n    allVersionList = c(all[,2],all[,3],all[,4],all[,5],all[,6],all[,7])\n    location = match(miRNAList, allVersionList)\n    sourceVersion = 16 + (location %/% 2602)\n    isNA = is.na(location)\n    targetVersion[which(!isNA)] = targetV\n    targetVersion[which(isNA)] = NA\n    location = location %% 2602\n    location[which(location == 0)] = 2602\n    targetName = all[location, targetV-14]\n  }\n  \n  res = cbind(sourceName, sourceVersion, targetName, targetVersion)\n  colnames(res) = c(\"sourceName\",\"sourceVersion\",\"targetName\",\"targetVersion\")\n  write.table(res, file=\"resOfConvert.csv\", sep=\",\",row.names = FALSE,col.names = TRUE)\n}\n\n\n\n\t\t\t\t",
    "created" : 1447072051742.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1929707456",
    "id" : "41B304E",
    "lastKnownWriteTime" : 1447140074,
    "path" : "D:/Dropbox/PROJECTS-WORKING/miRLAB-APPLICATION-NOTE/Project/miRLAB/R/miRLAB.R",
    "project_path" : "R/miRLAB.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}