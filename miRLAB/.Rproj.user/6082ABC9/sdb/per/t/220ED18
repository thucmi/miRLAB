{
    "contents" : "\n#Thuc add to increase heap size\noptions( java.parameters=\"-Xmx2048M\" )\n#library(\"rJava\")\n.jinit(classpath=\"MINE.jar\")\n\n###########################################\n# MINE - runs MINE on a comma-separated\n#  values (CSV) file. All parameters are as\n#  in the Java version. The parameters\n#  var1.id and var2.id are for use when\n#  the analysis style specified requires\n#  more information. For instance, since\n#  style=\"master.variable\" requires an\n#  additional variable id (the id of the\n#  master variable, you will need to\n#  specify var1.id in this case.\n#\n#  As in the Java version, if you do not\n#  specify a value for style, and you\n#  specify a value for var1.id and not\n#  var2.id, then style=\"master.variable\"\n#  will be assumed. If you do not specify a\n#  value for style, and you specify values\n#  for both var1.id and var2.id, then\n#  style=\"one.pair\" will be assumed.\n#\n# EXAMPLES:\n#  MINE(\"Spellman.csv\",\"all.pairs\",0)\n#  MINE(\"Spellman.csv\",0)\n#   will both run MINE on \"Spellman.csv\"\n#   and have it analyze each variable only\n#   against the 0-th variable.\n#\n#  MINE(\"Spellman.csv\",\"one.pair\",0,5)\n#  MINE(\"Spellman.csv\",0,5)\n#   will both run MINE on \"Spellman.csv\"\n#   and have it analyze only the 0-th\n#   variable against the 5-th variable.\n###########################################\n\nMINE <- function (\n\t\tinput.filename,\n\t\tstyle=c(\"master.variable\", \"all.pairs\", \"adjacent.pairs\", \"pairs.between\", \"one.pair\"),\n\t\tvar1.id=NA,\n\t\tvar2.id=NA,\n\t\trequired.common.vals.fraction=0,\n\t\tmax.num.boxes.exponent=0.6,\n\t\tnotify.wait=100,\n\t\tnum.clumps.factor=15,\n\t\tdebug.level=0,\n\t\tgc.wait=Inf,\n\t\tjob.id\n\t\t) {\n\n\tprintHeader()\n\n\tparams <- getParams(input.filename, style, var1.id, var2.id, required.common.vals.fraction, max.num.boxes.exponent, notify.wait, num.clumps.factor, debug.level, gc.wait, job.id)\n\n\t# run the analysis\n\tcat(\"reading in dataset...\\n\")\n\tflush.console()\n\n\tdataset <- .jnew(\"data/Dataset\",\n\t\t\t\tparams$inputfile,\n\t\t\t\tparams$analysisParams$mineParams$debug)\n\n\tcat(\"done.\\n\")\n\tflush.console()\n\n\tdoAnalysis(dataset, params)\n}\n\n###########################################\n# rMINE - runs MINE on an R matrix.\n#  all parameters are as in MINE, except\n#  that the name of the results file will\n#  begin with output.prefix rather than\n#  the name of the input file (since there\n#  is no input file).\n#\n#  MINE assumes that each row of the\n#  supplied matrix is a variable, and each\n#  column is a record.\n#\n# EXAMPLE:\n#  rMINE(matrix(1:10,2),\"matrix\",0)\n#   will run MINE on matrix(1:10,2),\n#   assuming that each of the two rows\n#   in the matrix is a variable.\n###########################################\nrMINE <- function (\n\t\tdata,\n\t\toutput.prefix,\n\t\tstyle=c(\"master.variable\", \"all.pairs\", \"adjacent.pairs\", \"pairs.between\", \"one.pair\"),\n\t\tvar1.id=NA,\n\t\tvar2.id=NA,\n\t\trequired.common.vals.fraction=0,\n\t\tmax.num.boxes.exponent=0.6,\n\t\tnotify.wait=100,\n\t\tnum.clumps.factor=15,\n\t\tdebug.level=0,\n\t\tgc.wait=Inf,\n\t\tjob.id\n\t\t) {\n\tprintHeader()\n\t\n\tif(missing(output.prefix))\n\t\tstop(\"you must specify output.prefix so that I'll know what to name the output file!\")\n\n\tparams <- getParams(output.prefix, style, var1.id, var2.id, required.common.vals.fraction, max.num.boxes.exponent, notify.wait, num.clumps.factor, debug.level, gc.wait, job.id)\n\n\t# run the analysis\n\tcat(\"reading in dataset...\\n\")\n\tflush.console()\n\n\tdata <- .jarray(data, dispatch=TRUE)\n\n\tdataset <- .jnew(\"data/Dataset\",\n\t\t\t\tdata, params$analysisParams$mineParams$debug)\n\tcat(\"done.\\n\")\n\tflush.console()\n\n\tdoAnalysis(dataset, params)\n}\n\nprintHeader <- function () {\n\t# print header\n\tcat(J(\"main/Analyze\")$header())\n\tcat(\"\\n\\n\")\n\tflush.console()\n}\n\ngetParams <- function(\n\t\tinput.filename,\n\t\tstyle=c(\"master.variable\", \"all.pairs\", \"adjacent.pairs\", \"pairs.between\", \"one.pair\"),\n\t\tvar1.id=NA,\n\t\tvar2.id=NA,\n\t\trequired.common.vals.fraction=0,\n\t\tmax.num.boxes.exponent=0.6,\n\t\tnotify.wait=100,\n\t\tnum.clumps.factor=15,\n\t\tdebug.level=0,\n\t\tgc.wait=Inf,\n\t\tjob.id\n\t\t) {\n\tif (gc.wait==Inf) gc.wait <- J(\"java.lang.Integer\")$MAX_VALUE\n\telse gc.wait <- as.integer(gc.wait)\n\n\t# create parameters object\t\n\tif(missing(job.id)) {\n\t\targs <- .jarray(c(\n\t\t\t\tinput.filename,\n\t\t\t\tstyle,\n\t\t\t\tvar1.id,\n\t\t\t\tvar2.id,\n\t\t\t\tpaste(\"cv=\", required.common.vals.fraction, sep = \"\"),\n\t\t\t\tpaste(\"exp=\", max.num.boxes.exponent, sep = \"\"),\n\t\t\t\tpaste(\"notify=\", notify.wait, sep = \"\"),\n\t\t\t\tpaste(\"c=\", num.clumps.factor, sep = \"\"),\n\t\t\t\tpaste(\"d=\", debug.level, sep = \"\"),\n\t\t\t\tpaste(\"gc=\", gc.wait, sep = \"\")\n\t\t))\n\t} else {\n\t\targs <- .jarray(c(\n\t\t\t\tinput.filename,\n\t\t\t\tstyle,\n\t\t\t\tvar1.id,\n\t\t\t\tvar2.id,\n\t\t\t\tpaste(\"cv=\", required.common.vals.fraction, sep = \"\"),\n\t\t\t\tpaste(\"exp=\", max.num.boxes.exponent, sep = \"\"),\n\t\t\t\tpaste(\"notify=\", notify.wait, sep = \"\"),\n\t\t\t\tpaste(\"c=\", num.clumps.factor, sep = \"\"),\n\t\t\t\tpaste(\"d=\", debug.level, sep = \"\"),\n\t\t\t\tpaste(\"gc=\", gc.wait, sep = \"\"),\n\t\t\t\tpaste(\"id=\", job.id, sep = \"\")\n\t\t))\n\t}\n\n\tparams <- .jnew(\"main/JobParameters\", args)\n\tflush.console()\n\n\t#confirm parameters for user\n\tcat(params$toString())\n\tcat(\"\\n\")\n\tflush.console()\n\n\tparams\n}\n\ndoAnalysis <- function (dataset, params) {\n\ttoAnalyze <- .jnew(\"analysis/VarPairQueue\", dataset)\n\t\n\tparams$analysisStyle$addVarPairsTo(toAnalyze, dataset$numVariables())\n\t\n\ta <- .jnew(\"analysis/Analysis\", dataset, toAnalyze)\n\n\tcat(\"Analyzing...\\n\")\n\tflush.console()\n\n\twhile(! a$varPairQueue()$isEmpty()) {\n\t\t# print a status update\n\t\tstatusUpdate <- paste(a$numResults() + 1, \" calculating: \", a$varPairQueue()$peek()$var1$name(), \" vs \", a$varPairQueue()$peek()$var2$name(), \"...\\n\", sep=\"\")\n\t\tcat(statusUpdate)\n\t\tflush.console()\n\n\t\t# create a file containing the status update (for use when running on a cluster)\n\t\twrite(statusUpdate, file=params$statusFileName())\n\t\t\t\n\t\t# analyze some more pairs\n\t\ta$analyzePairs(J(\"analysis.results/BriefResult\")$class,\n\t\t\t\t\tparams$analysisParams,\n\t\t\t\t\tparams$notifyWait)\n\t}\n\n\tcat(paste(a$numResults(), \" variable pairs analyzed.\\n\", \"Sorting results in descending order...\\n\", sep=\"\"))\n\tflush.console()\n\n\tresults <- a$getSortedResults()\n\n\tcat(\"done. printing results\\n\")\n\tflush.console()\n\n\t#print the results\n\trepeat {\n\t\tif(J(\"main/Analyze\")$printResults(results, params)) {\n\t\t\tbreak\n\t\t}\n\t\telse {\n\t\t\tn <- readline(\"writing results to output file failed. Perhaps it is locked in some way. Enter 1 to try again, 0 otherwise: \")\n\t\t\tif(n == 0) break\n\t\t}\t\t\t\n\t}\n\n\tcat(\"Analysis finished. See file \\\"\")\n\tcat(params$resultsFileName())\n\tcat(\"\\\" for output\\n\")\n}\n",
    "created" : 1431867318376.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "792898681",
    "id" : "220ED18",
    "lastKnownWriteTime" : 1430892106,
    "path" : "D:/Dropbox/PROJECTS-WORKING/miRLAB-APPLICATION-NOTE/Project/miRLAB/R/MINE.R",
    "project_path" : "R/MINE.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}